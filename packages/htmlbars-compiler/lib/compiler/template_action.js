var push = Array.prototype.push;

function Frame() {
  this.childIndex = null;
  this.childCount = null;
  this.childTemplateCount = 0;
  this.mustacheCount = 0;
  this.actions = [];
}

/**
 * Takes in an AST and outputs a list of actions to be consumed
 * by a compiler. For example, the template
 *
 *     foo{{bar}}<div>baz</div>
 *
 * produces the actions
 *
 *     [['startTemplate', [programNode, 0]],
 *      ['text', [textNode, 0, 3]],
 *      ['mustache', [mustacheNode, 1, 3]],
 *      ['openElement', [elementNode, 2, 3, 0]],
 *      ['text', [textNode, 0, 1]],
 *      ['closeElement', [elementNode, 2, 3],
 *      ['endTemplate', [programNode]]]
 *
 * This compiler walks the AST depth first and backwards. As
 * a result the bottom-most child template will appear at the
 * top of the actions list whereas the root template will appear
 * at the bottom of the list. For example,
 *
 *     <div>{{#if}}foo{{else}}bar<b></b>{{/if}}</div>
 *
 * produces the actions
 *
 *     [['startTemplate', [programNode, 0]],
 *      ['text', [textNode, 0, 2, 0]],
 *      ['openElement', [elementNode, 1, 2, 0]],
 *      ['closeElement', [elementNode, 1, 2]],
 *      ['endTemplate', [programNode]],
 *      ['startTemplate', [programNode, 0]],
 *      ['text', [textNode, 0, 1]],
 *      ['endTemplate', [programNode]],
 *      ['startTemplate', [programNode, 2]],
 *      ['openElement', [elementNode, 0, 1, 1]],
 *      ['block', [blockNode, 0, 1]],
 *      ['closeElement', [elementNode, 0, 1]],
 *      ['endTemplate', [programNode]]]
 *
 * The state of the traversal is maintained by a stack of frames.
 * Whenever a node with children is entered (either a ProgramNode
 * or an ElementNode) a frame is pushed onto the stack. The frame
 * contains information about the state of the traversal of that
 * node. For example,
 * 
 *   - index of the current child node being visited
 *   - the number of mustaches contained within its child nodes
 *   - the list of actions generated by its child nodes
 */

function TemplateActionCompiler() {
  this.frameStack = [];
  this.actions = [];
}

// Traversal methods

TemplateActionCompiler.prototype.compile = function(ast) {
  this.visit(ast);
  return this.actions;
};

TemplateActionCompiler.prototype.visit = function(node) {
  this[node.type](node);
};

TemplateActionCompiler.prototype.program = function(program) {
  var parentFrame = this.getCurrentFrame();
  var programFrame = this.pushFrame();

  programFrame.childCount = program.statements.length;
  programFrame.actions.push(['endTemplate', [program]]);

  for (var i = program.statements.length - 1; i >= 0; i--) {
    programFrame.childIndex = i;
    this.visit(program.statements[i]);
  }

  programFrame.actions.push(['startTemplate', [program, programFrame.childTemplateCount]]);
  this.popFrame();

  // Push the completed template into the compiler's actions list
  if (parentFrame) { parentFrame.childTemplateCount++; }
  push.apply(this.actions, programFrame.actions.reverse());
};

TemplateActionCompiler.prototype.element = function(element) {
  var parentFrame = this.getCurrentFrame();
  var elementFrame = this.pushFrame();

  elementFrame.childCount = element.children.length;
  elementFrame.mustacheCount += element.helpers.length;
  elementFrame.actions.push(['closeElement', [element, parentFrame.childIndex, parentFrame.childCount]]);

  for (var i = element.attributes.length - 1; i >= 0; i--) {
    this.visit(element.attributes[i]);
  }

  for (i = element.children.length - 1; i >= 0; i--) {
    elementFrame.childIndex = i;
    this.visit(element.children[i]);
  }

  elementFrame.actions.push(['openElement', [element, parentFrame.childIndex, parentFrame.childCount, elementFrame.mustacheCount]]);
  this.popFrame();

  // Propagate the element's frame state to the parent frame
  if (elementFrame.mustacheCount > 0) { parentFrame.mustacheCount++; }
  parentFrame.childTemplateCount += elementFrame.childTemplateCount;
  push.apply(parentFrame.actions, elementFrame.actions);
};

TemplateActionCompiler.prototype.attr = function(attr) {
  if (attr.value.type === 'mustache') {
    this.getCurrentFrame().mustacheCount++;
  }
};

TemplateActionCompiler.prototype.block = function(node) {
  var frame = this.getCurrentFrame();
  frame.mustacheCount++;
  frame.actions.push([node.type, [node, frame.childIndex, frame.childCount]]);

  if (node.inverse) { this.visit(node.inverse); }
  if (node.program) { this.visit(node.program); }
};

TemplateActionCompiler.prototype.component = TemplateActionCompiler.prototype.block;

TemplateActionCompiler.prototype.text = function(text) {
  var frame = this.getCurrentFrame();
  frame.actions.push(['text', [text, frame.childIndex, frame.childCount]]);
};

TemplateActionCompiler.prototype.mustache = function(mustache) {
  var frame = this.getCurrentFrame();
  frame.mustacheCount++;
  frame.actions.push(['mustache', [mustache, frame.childIndex, frame.childCount]]);
};

// Frame helpers

TemplateActionCompiler.prototype.getCurrentFrame = function() {
  return this.frameStack[this.frameStack.length - 1];
};

TemplateActionCompiler.prototype.pushFrame = function() {
  var frame = new Frame();
  this.frameStack.push(frame);
  return frame;
};

TemplateActionCompiler.prototype.popFrame = function() {
  return this.frameStack.pop();
};

export default TemplateActionCompiler;
