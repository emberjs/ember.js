import { Dict, InternedString } from 'glimmer-util';

type JsonValue =
    string
  | number
  | boolean
  | JsonObject
  | JsonArray
  ;

interface JsonObject extends Dict<JsonValue> {}
interface JsonArray extends Array<JsonValue> {}

// This entire file is serialized to disk, so all strings
// end up being interned.
export type str = string;
export type TemplateReference = number;
export type YieldTo = str;

function is<T extends any[]>(variant: string): (value: any[]) => value is T {
  return function(value: any[]): value is T {
    return value[0] === variant;
  };
}

export namespace Core {
  type Expression = Expressions.Expression;

  export type Path          = str[];
  export type Params        = Expression[];
  export type Hash          = Dict<Expression>;
}

export namespace Expressions {
  type Path = Core.Path;
  type Params = Core.Params;
  type Hash = Core.Hash;

  export type Unknown       = ['unknown', Path];
  export type Attr          = ['attr', Path];
  export type Get           = ['get', Path];
  export type Value         = str | number | boolean;

  export type Expression =
      Unknown
    | Attr
    | Get
    | Concat
    | Helper
    | Value
    ;

  export interface Concat extends Array<any> {
    [0]: 'concat';
    [1]: Params;
  }

  export interface Helper extends Array<any> {
    [0]: 'helper';
    [1]: Path;
    [2]: Params;
    [3]: Hash;
  }

  export const isUnknown      = is<Unknown>('unknown');
  export const isAttr         = is<Attr>('attr');
  export const isGet          = is<Get>('get');
  export const isConcat       = is<Concat>('concat');
  export const isHelper       = is<Helper>('helper');

  export function isValue(value: any): value is Value {
    return value !== null && typeof value !== 'object';
  }
}

export type Expression = Expressions.Expression;

export namespace Statements {
  type Expression = Expressions.Expression;
  type Params = Core.Params;
  type Hash = Core.Hash;
  type Path = Core.Path;

  export type Text          = ['text', str];
  export type Append        = ['append', Expression, boolean];
  export type Comment       = ['comment', str];
  export type Modifier      = ['modifier', Path, Params, Hash];
  export type Block         = ['block', Path, Params, Hash, TemplateReference, TemplateReference];
  export type Component     = ['component', str, Hash, TemplateReference];
  export type OpenElement   = ['openElement', str, str[]];
  export type CloseElement  = ['closeElement'];
  export type AddClass      = ['addClass', Expression];
  export type StaticAttr    = ['staticAttr', str, Expression, str];
  export type DynamicAttr   = ['dynamicAttr', str, Expression, str];
  export type DynamicProp   = ['dynamicProp', str, Expression];
  export type Yield         = ['yield', YieldTo, Params];

  export const isText         = is<Text>('text');
  export const isAppend       = is<Append>('append');
  export const isComment      = is<Comment>('comment');
  export const isModifier     = is<Modifier>('modifier');
  export const isBlock        = is<Block>('block');
  export const isComponent    = is<Component>('component');
  export const isOpenElement  = is<OpenElement>('openElement');
  export const isCloseElement = is<CloseElement>('closeElement');
  export const isAddClass     = is<AddClass>('addClass');
  export const isStaticAttr   = is<StaticAttr>('staticAttr');
  export const isDynamicAttr  = is<DynamicAttr>('dynamicAttr');
  export const isDynamicProp  = is<DynamicProp>('dynamicProp');
  export const isYield        = is<Yield>('yield');

  export type Statement =
      Text
    | Append
    | Comment
    | Modifier
    | Block
    | Component
    | OpenElement
    | CloseElement
    | AddClass
    | StaticAttr
    | DynamicAttr
    | DynamicProp
    | Yield
    ;
}

export type Statement = Statements.Statement;

export interface SerializedTemplate {
  statements: Statements.Statement[];
  locals: InternedString[];
  named: InternedString[];
  yields: InternedString[];
  blocks: SerializedBlock[];
  meta: Object;
}

export interface SerializedBlock {
  statements: Statements.Statement[];
  locals: InternedString[];
}
