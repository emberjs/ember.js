import { NULL_REFERENCE } from '../../references';
import { CompiledExpression } from '../expressions';
import VM from '../../vm/append';
import { PathReference } from 'glimmer-reference';
import { InternedString, Dict, dict } from 'glimmer-util';

export abstract class CompiledNamedArgs {
  static create({ map }: { map: Dict<CompiledExpression> }): CompiledNamedArgs {
    if (Object.keys(map).length) {
      return new CompiledNonEmptyNamedArgs({ map });
    } else {
      return COMPILED_EMPTY_NAMED_ARGS;
    }
  }

  public type: string;
  abstract evaluate(vm: VM): EvaluatedNamedArgs;
}

class CompiledNonEmptyNamedArgs extends CompiledNamedArgs {
  public type = "named-args";
  public map: Dict<CompiledExpression>;

  constructor({ map }: { map: Dict<CompiledExpression> }) {
    super();
    this.map = map;
  }

  evaluate(vm: VM): EvaluatedNamedArgs {
    let { map } = this;

    let compiledMap = dict<PathReference>();

    Object.keys(map).forEach(key => {
      compiledMap[key] = map[key].evaluate(vm);
    });

    return EvaluatedNamedArgs.create({ map: compiledMap });
  }
}

export const COMPILED_EMPTY_NAMED_ARGS = new (class extends CompiledNamedArgs {
  public type = "empty-named-args";

  evaluate(vm): EvaluatedNamedArgs {
    return EvaluatedNamedArgs.empty();
  }
});

export abstract class EvaluatedNamedArgs {
  static empty(): EvaluatedNamedArgs {
    return EVALUATED_EMPTY_NAMED_ARGS;
  }

  static create({ map }: { map: Dict<PathReference> }) {
    return new NonEmptyEvaluatedNamedArgs({ map });
  }

  public type: string;
  public map: Dict<PathReference>;

  forEach(callback: (key: InternedString, value: PathReference) => void) {
    let { map } = this;

    Object.keys(map).forEach(key => {
      callback(key as InternedString, map[key]);
    });
  }

  abstract get(key: InternedString): PathReference;
  abstract has(key: InternedString): boolean;
  abstract value(): Dict<any>;
}

class NonEmptyEvaluatedNamedArgs extends EvaluatedNamedArgs {
  public values: PathReference[];
  public keys: InternedString[];
  public map: Dict<PathReference>;

  constructor({ map }: { map: Dict<PathReference> }) {
    super();

    this.map = map;
  }

  get(key: InternedString): PathReference {
    return this.map[<string>key];
  }

  has(key: InternedString): boolean {
    return !!this.map[<string>key];
  }

  value(): Dict<any> {
    let { map } = this;

    let out = dict();

    Object.keys(map).forEach(key => {
      out[key] = map[key].value();
    });

    return out;
  }
}

export const EVALUATED_EMPTY_NAMED_ARGS = new (class extends EvaluatedNamedArgs {
  get(): PathReference {
    return NULL_REFERENCE;
  }

  has(key: InternedString): boolean {
    return false;
  }

  value(): Dict<any> {
    return null;
  }
});