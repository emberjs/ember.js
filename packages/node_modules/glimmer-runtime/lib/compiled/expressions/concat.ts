import { CompiledExpression } from '../expressions';
import VM from '../../vm/append';
import { PathReference, ChainableReference } from 'glimmer-reference';

export default class CompiledConcat {
  public type = "concat";
  public parts: CompiledExpression[];

  constructor({ parts }: { parts: CompiledExpression[] }) {
    this.parts = parts;
  }

  evaluate(vm: VM): ConcatReference {
    let parts = new Array(this.parts.length);
    for (let i = 0; i < this.parts.length; i++) {
      parts[i] = this.parts[i].evaluate(vm);
    }
    return new ConcatReference(parts);
  }

  toJSON(): string {
    return `concat(${this.parts.map(expr => expr.toJSON()).join(", ")})`;
  }
}

class ConcatReference implements ChainableReference {
  private parts: PathReference[];

  constructor(parts: PathReference[]) {
    this.parts = parts;
  }

  isDirty() {
    return true;
  }

  value() {
    let parts = new Array(this.parts.length);
    for (let i = 0; i < this.parts.length; i++) {
      parts[i] = this.parts[i].value();
    }
    return parts.join('');
  }

  destroy() {}
}
