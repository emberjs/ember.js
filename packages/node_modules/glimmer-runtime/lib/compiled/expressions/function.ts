import { PathReference } from 'glimmer-reference';
import { Expression as ExpressionSyntax } from '../../syntax';
import { CompiledExpression } from '../expressions';
import { PublicVM as VM } from '../../vm';

export type FunctionExpression = (VM) => PathReference;

export default function make(func: FunctionExpression): ExpressionSyntax {
  return new FunctionExpressionSyntax(func);
}

class FunctionExpressionSyntax extends ExpressionSyntax {
  private func: FunctionExpression;

  constructor(func: FunctionExpression) {
    super();
    this.func = func;
  }

  compile(): CompiledExpression {
    return new CompiledFunctionExpression(this.func);
  }
}

class CompiledFunctionExpression extends CompiledExpression {
  type = "function";

  private func: FunctionExpression;

  constructor(func: FunctionExpression) {
    super();
    this.func = func;
  }

  evaluate(vm: VM) {
    return this.func.call(undefined, vm);
  }

  toJSON(): string {
    let { func } = this;

    if (func.name) {
      return `\`${func.name}(...)\``;
    } else {
      return "`func(...)`";
    }
  }
}
