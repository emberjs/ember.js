import { CompiledExpression } from '../expressions';
import VM from '../../vm/append';
import { InternedString } from 'glimmer-util';
import { PathReference, referenceFromParts } from 'glimmer-reference';

export abstract class CompiledSymbolRef extends CompiledExpression {
  protected debug: string;
  protected symbol: number;
  protected path: InternedString[];

  constructor({ debug, symbol, path }: { debug: string, symbol: number, path: InternedString[] }) {
    super();
    this.debug = debug;
    this.symbol = symbol;
    this.path = path;
  }

  evaluate(vm: VM): PathReference {
    let base = this.referenceForSymbol(vm);
    return referenceFromParts(base, this.path);
  }

  protected abstract referenceForSymbol(vm: VM): PathReference;

  toJSON(): string {
    let { debug, symbol, path } = this;

    if (path.length) {
      return `$${symbol}(${debug}).${path.join('.')}`;
    } else {
      return `$${symbol}(${debug})`;
    }
  }
}

export class CompiledKeywordRef extends CompiledSymbolRef {
  public type = "keyword-ref";

  referenceForSymbol(vm: VM): PathReference {
    return vm.referenceForKeyword(this.symbol);
  }
}

export class CompiledLocalRef extends CompiledSymbolRef {
  public type = "local-ref";

  referenceForSymbol(vm: VM): PathReference {
    return vm.referenceForSymbol(this.symbol);
  }
}

export class CompiledSelfRef extends CompiledExpression {
  public type = "self-ref";
  private parts: InternedString[];

  constructor({ parts }: { parts: InternedString[] }) {
    super();
    this.parts = parts;
  }

  evaluate(vm: VM): PathReference {
    return referenceFromParts(vm.getSelf(), this.parts);
  }

  toJSON(): string {
    let path = ['self'];
    path.push(...this.parts);
    return path.join('.');
  }
}
