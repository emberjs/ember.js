import { Opcode, OpcodeJSON, UpdatingOpcode } from '../../opcodes';
import { VM, UpdatingVM } from '../../vm';
import { InternedString, dict } from 'glimmer-util';
import { ChainableReference } from 'glimmer-reference';

abstract class DOMUpdatingOpcode extends UpdatingOpcode {
  public type: string;
  public next = null;
  public prev = null;

  abstract evaluate(vm: UpdatingVM);
}

export class TextOpcode extends Opcode {
  public type = "text";
  public text: InternedString;

  constructor({ text }: { text: InternedString }) {
    super();
    this.text = text;
  }

  evaluate(vm: VM) {
    vm.stack().appendText(this.text);
  }

  toJSON(): OpcodeJSON {
    return {
      guid: this._guid,
      type: this.type,
      args: [JSON.stringify(this.text)]
    };
  }
}

export class OpenPrimitiveElementOpcode extends Opcode {
  public type = "open-primitive-element";
  public tag: InternedString;

  constructor({ tag }: { tag: InternedString }) {
    super();
    this.tag = tag;
  }

  evaluate(vm: VM) {
    vm.stack().openElement(this.tag);
  }

  toJSON(): OpcodeJSON {
    return {
      guid: this._guid,
      type: this.type,
      args: [JSON.stringify(this.tag)]
    };
  }
}

export class CloseElementOpcode extends Opcode {
  public type = "close-element";

  evaluate(vm: VM) {
    let { element, classList, classNames } = vm.stack().closeElement();

    if (classList) {
      vm.updateWith(new UpdateAttributeOpcode(element, "class", classList, classNames));
    }
  }
}

export class StaticAttrOpcode extends Opcode {
  public type = "static-attr";
  public name: InternedString;
  public value: InternedString;
  public namespace: InternedString;

  constructor({ name, value, namespace }: { name: InternedString, value: InternedString, namespace: InternedString }) {
    super();
    this.name = name;
    this.value = value;
    this.namespace = namespace;
  }

  evaluate(vm: VM) {
    let { name, value, namespace } = this;

    if (this.namespace) {
      vm.stack().setAttributeNS(name, value, namespace);
    } else {
      vm.stack().setAttribute(name, value);
    }
  }

  toJSON(): OpcodeJSON {
    let { _guid: guid, type, name, value, namespace } = this;

    let details = dict<string>();

    details["name"] = JSON.stringify(name);
    details["value"] = JSON.stringify(value)

    if (namespace) {
      details["namespace"] = JSON.stringify(namespace);
    }

    return { guid, type, details };
  }
}

export class DynamicAttrOpcode extends Opcode {
  public type = "dynamic-attr";
  public name: InternedString;
  public namespace: InternedString;

  constructor({ name, namespace }: { name: InternedString, namespace: InternedString }) {
    super();
    this.name = name;
    this.namespace = namespace;
  }

  evaluate(vm: VM) {
    let { name, namespace } = this;
    let reference = vm.frame.getOperand();
    let value = reference.value();

    if (this.namespace) {
      vm.stack().setAttributeNS(name, value, namespace);
    } else {
      vm.stack().setAttribute(name, value);
    }

    vm.updateWith(new UpdateAttributeOpcode(vm.stack().element, name, reference, value));
  }

  toJSON(): OpcodeJSON {
    let { _guid: guid, type, name, namespace } = this;

    let details = dict<string>();

    details["name"] = JSON.stringify(name);
    details["value"] = "<OPERAND>";

    if (namespace) {
      details["namespace"] = JSON.stringify(namespace);
    }

    return { guid, type, details };
  }
}

export class UpdateAttributeOpcode extends DOMUpdatingOpcode {
  public type = "update-attribute";

  private element: Element;
  private name: string;
  private namespace: string;
  private reference: ChainableReference;
  private lastValue: string;

  constructor(element: Element, name: string, reference: ChainableReference, lastValue: string, namespace?: string) {
    super();
    this.element = element;
    this.name = name;
    this.reference = reference;
    this.lastValue = lastValue;
    this.namespace = namespace;
  }

  evaluate(vm: UpdatingVM) {
    let value = this.reference.value();

    if (value !== this.lastValue) {
      if (this.namespace) {
        vm.dom.setAttributeNS(this.element, this.name, value, this.namespace);
      } else {
        vm.dom.setAttribute(this.element, this.name, value);
      }

      this.lastValue = value;
    }
  }

  toJSON(): OpcodeJSON {
    let { _guid: guid, type, name, lastValue, namespace } = this;

    let details = dict<string>();

    details["name"] = JSON.stringify(name);
    details["lastValue"] = JSON.stringify(lastValue);

    if (namespace) {
      details["namespace"] = JSON.stringify(namespace);
    }

    return { guid, type, details };
  }
}

export class DynamicPropOpcode extends Opcode {
  public type = "dynamic-prop";
  public name: InternedString;

  constructor({ name }: { name: InternedString }) {
    super();
    this.name = name;
  }

  evaluate(vm: VM) {
    let { name } = this;
    let element = vm.stack().element;
    let reference = vm.frame.getOperand();
    let value = reference.value();

    element[<string>name] = value;

    vm.updateWith(new UpdatePropertyOpcode(element, name, reference, value));
  }

  toJSON(): OpcodeJSON {
    let { _guid: guid, type, name } = this;

    let details = dict<string>();

    details["name"] = JSON.stringify(name);
    details["value"] = "<OPERAND>";

    return { guid, type, details };
  }
}

export class UpdatePropertyOpcode extends DOMUpdatingOpcode {
  public type = "update-property";

  private element: Element;
  private name: string;
  private reference: ChainableReference;
  private lastValue: any;

  constructor(element: Element, name: string, reference: ChainableReference, lastValue: any) {
    super();
    this.element = element;
    this.name = name;
    this.reference = reference;
    this.lastValue = lastValue;
  }

  evaluate(vm: UpdatingVM) {
    let value = this.reference.value();

    if (value !== this.lastValue) {
      this.lastValue = this.element[this.name] = value;
    }
  }
}

export class AddClassOpcode extends Opcode {
  public type = "add-class";

  evaluate(vm: VM) {
    vm.stack().addClass(vm.frame.getOperand());
  }

  toJSON(): OpcodeJSON {
    return {
      guid: this._guid,
      type: this.type,
      args: ["<OPERAND>"]
    };
  }
}

export class CommentOpcode extends Opcode {
  public type = "comment";
  public comment: InternedString;

  constructor({ comment }: { comment: InternedString }) {
    super();
    this.comment = comment;
  }

  evaluate(vm: VM) {
    vm.stack().appendComment(this.comment);
  }

  toJSON(): OpcodeJSON {
    return {
      guid: this._guid,
      type: this.type,
      args: [JSON.stringify(this.comment)]
    };
  }
}
