import { Statement as StatementSyntax } from './syntax';

import { DOMHelper } from './dom';
import { Reference } from 'glimmer-reference';
import { NULL_REFERENCE, ConditionalReference } from './references';

import {
  Component,
  ComponentManager,
  ComponentDefinition
} from './component/interfaces';

import {
  PathReference,
  ConstReference,
} from 'glimmer-reference';

import {
  HasGuid,
  InternedString,
  intern,
  ensureGuid
} from 'glimmer-util';

import { InlineBlock } from './compiled/blocks';

import { Dict } from 'glimmer-util';

import * as Syntax from './syntax/core';

import IfSyntax from './syntax/builtins/if';
import UnlessSyntax from './syntax/builtins/unless';
import WithSyntax from './syntax/builtins/with';

type ScopeSlot = PathReference | InlineBlock;

export class Scope {
  static root(self: PathReference, size = 0) {
    let refs: PathReference[] = new Array(size + 1);

    for (let i = 0; i <= size; i++) {
      refs[i] = NULL_REFERENCE;
    }

    return new Scope(refs).init({ self });
  }

  // the 0th slot is `self`
  private slots: ScopeSlot[];
  private callerScope: Scope = null;

  constructor(references: ScopeSlot[]) {
    this.slots = references;
  }

  init({ self }: { self: PathReference }): this {
    this.slots[0] = self;
    return this;
  }

  getSelf(): PathReference {
    return this.slots[0] as PathReference;
  }

  getSymbol(symbol: number): PathReference {
    return this.slots[symbol] as PathReference;
  }

  getBlock(symbol: number): InlineBlock {
    return this.slots[symbol] as InlineBlock;
  }

  bindSymbol(symbol: number, value: PathReference) {
    this.slots[symbol] = value;
  }

  bindBlock(symbol: number, value: InlineBlock) {
    this.slots[symbol] = value;
  }

  bindCallerScope(scope: Scope) {
    this.callerScope = scope;
  }

  getCallerScope(): Scope {
    return this.callerScope;
  }

  child() {
    return new Scope(this.slots.slice());
  }
}

export abstract class Environment {
  protected dom: DOMHelper;
  private createdComponents: Component[] = [];
  private createdManagers: ComponentManager<any>[] = [];
  private updatedComponents: Component[] = [];
  private updatedManagers: ComponentManager<any>[] = [];

  constructor(dom: DOMHelper) {
    this.dom = dom;
  }

  toConditionalReference(reference: Reference): ConditionalReference {
    return new ConditionalReference(reference);
  }

  getDOM(): DOMHelper { return this.dom; }

  getIdentity(object: HasGuid): InternedString {
    return intern(ensureGuid(object) + '');
  }

  createRootScope(self: PathReference, size: number): Scope {
    return Scope.root(self, size);
  }

  statement(statement: StatementSyntax): StatementSyntax {
    let type = statement.type;
    let block = type === 'block' ? <Syntax.Block>statement : null;
    let append = type === 'append' ? <Syntax.Append>statement : null;

    let named: Syntax.NamedArgs;
    let args: Syntax.Args;
    let path: InternedString[];
    let unknown: Syntax.Unknown;
    let helper: Syntax.Helper;

    if (block) {
      args = block.args;
      named = args.named;
      path = block.path;
    } else if (append && append.value.type === 'unknown') {
      unknown = <Syntax.Unknown>append.value;
      args = Syntax.Args.empty();
      named = Syntax.NamedArgs.empty();
      path = unknown.ref.path();
    } else if (append && append.value.type === 'helper') {
      helper = <Syntax.Helper>append.value;
      args = helper.args;
      named = args.named;
      path = helper.ref.path();
    }

    let key: InternedString, isSimple: boolean;

    if (path) {
      isSimple = path.length === 1;
      key = path[0];
    }

    if (isSimple && block) {
      switch (key) {
        // case 'each':
        //   return new EachSyntax({ args: block.args, templates: block.templates });
        case 'if':
          return new IfSyntax({ args: block.args, templates: block.templates });
        case 'with':
          return new WithSyntax({ args: block.args, templates: block.templates });
        case 'unless':
          return new UnlessSyntax({ args: block.args, templates: block.templates });
      }
    }

    return statement;
  }

  begin() {
    this.createdComponents = [];
    this.createdManagers = [];
    this.updatedComponents = [];
    this.updatedManagers = [];
  }

  didCreate<T extends Component>(component: T, manager: ComponentManager<T>) {
    this.createdComponents.push(component);
    this.createdManagers.push(manager);
  }

  didUpdate<T extends Component>(component: T, manager: ComponentManager<T>) {
    this.updatedComponents.push(component);
    this.updatedManagers.push(manager);
  }

  commit() {
    for (let i=0; i<this.createdComponents.length; i++) {
      let component = this.createdComponents[i];
      let manager = this.createdManagers[i];
      manager.didCreate(component);
    }

    for (let i=0; i<this.updatedComponents.length; i++) {
      let component = this.updatedComponents[i];
      let manager = this.updatedManagers[i];
      manager.didUpdate(component);
    }
  }

  iteratorFor(iterable: PathReference) {
    let position = 0;
    let len = iterable.value().length;

    return {
      next() {
        if (position >= len) return { done: true, value: undefined };

        position++;

        return {
          done: false,
          value: iterable.get(intern("" + (position - 1)))
        };
      }
    };
  }

  abstract rootReferenceFor(obj: any): PathReference;
  abstract hasHelper(helperName: InternedString[]): boolean;
  abstract lookupHelper(helperName: InternedString[]): Helper;
  abstract hasComponentDefinition(tagName: InternedString[], syntax: StatementSyntax): boolean;
  abstract getComponentDefinition(tagName: InternedString[], syntax: StatementSyntax): ComponentDefinition<any>;
}

export default Environment;

// TS does not allow us to use computed properties for this, so inlining for now
// import { TRUSTED_STRING } from './symbols';

interface SafeString {
  "trusted string [id=7d10c13d-cdf5-45f4-8859-b09ce16517c2]": boolean; // true
  string: string;
}

export type Insertion = string | SafeString | Node;

type PositionalArguments = any[];
type KeywordArguments = Dict<any>;

export interface Helper {
  (positional: PositionalArguments, named: KeywordArguments, options: Object): Insertion;
}

export function helper(h: Helper): ConstReference<Helper> {
  return new ConstReference(h);
}