import { FIXME, Slice, LinkedList, InternedString } from 'glimmer-util';
import { OpSeqBuilder, Opcode } from './opcodes';
import { Layout as CompiledLayout } from './compiled/blocks';
import { BindNamedArgsOpcode, BindBlocksOpcode, BindPositionalArgsOpcode } from './compiled/opcodes/vm';
import * as Syntax from './syntax/core';
import { Environment } from './environment';
import SymbolTable from './symbol-table';
import { Block, EntryPoint, InlineBlock, Layout } from './compiled/blocks';
import { Args, Templates } from './syntax/core';
import {
  OpenComponentOpcode,
  CloseComponentOpcode
} from './compiled/opcodes/component';

import {
  Statement as StatementSyntax,
  Attribute as AttributeSyntax,
  CompileInto
} from './syntax';

import {
  FunctionExpression,
  default as makeFunctionExpression
} from './compiled/expressions/function';

import {
  ComponentDefinition
} from './component/interfaces';

import * as Component from './component/interfaces';

abstract class Compiler {
  public env: Environment;
  protected block: Block;
  protected symbolTable: SymbolTable;
  protected current: StatementSyntax;

  constructor(block: Block, env: Environment) {
    this.block = block;
    this.current = block.program.head();
    this.env = env;
    this.symbolTable = block.symbolTable;
  }

  protected compileStatement(statement: StatementSyntax, ops: CompileIntoList) {
    this.env.statement(statement).compile(ops, this.env);
  }

}

export default Compiler;

export class EntryPointCompiler extends Compiler {
  private ops: CompileIntoList;
  protected block: EntryPoint;

  constructor(template: EntryPoint, env: Environment) {
    super(template, env);
    this.ops = new CompileIntoList(env, template.symbolTable);
  }

  compile(): OpSeqBuilder {
    let { block, ops } = this;
    let { program } = block;

    let current = program.head();

    while (current) {
      let next = program.nextNode(current);
      this.compileStatement(current, ops);
      current = next;
    }

    return ops;
  }

  append(op: Opcode) {
    this.ops.append(op);
  }

  getLocalSymbol(name: InternedString): number {
    return this.symbolTable.getLocal(name);
  }

  getNamedSymbol(name: InternedString): number {
    return this.symbolTable.getNamed(name);
  }

  getYieldSymbol(name: InternedString): number {
    return this.symbolTable.getYield(name);
  }
}

export class InlineBlockCompiler extends Compiler {
  private ops: CompileIntoList;
  protected block: InlineBlock;
  protected current: StatementSyntax;

  constructor(block: InlineBlock, env: Environment) {
    super(block, env);
    this.ops = new CompileIntoList(env, block.symbolTable);
  }

  compile(): CompileIntoList {
    let { block, ops } = this;
    let { program } = block;

    if (block.hasPositionalParameters()) {
      ops.append(new BindPositionalArgsOpcode({ block }));
    }

    let current = program.head();

    while (current) {
      let next = program.nextNode(current);
      this.compileStatement(current, ops);
      current = next;
    }

    return ops;
  }
}

export interface ComponentParts {
  tag: InternedString;
  attrs: Slice<AttributeSyntax>;
  body: Slice<StatementSyntax>;
}

export interface CompiledComponentParts {
  tag: InternedString;
  preamble: CompileIntoList;
  main: CompileIntoList;
}

class ComponentBuilder implements Component.ComponentBuilder {
  private tagName: InternedString = null;
  public body = new ComponentBodyBuilder();
  public attrs = new ComponentAttrsBuilder();

  tag(tagName: InternedString) {
    this.tagName = tagName;
  }

  toParts(): ComponentParts {
    return {
      tag: this.tagName,
      attrs: this.attrs.asSlice(),
      body: this.body.asSlice()
    };
  }
}

class ComponentAttrsBuilder implements Component.ComponentAttrsBuilder {
  private buffer: LinkedList<AttributeSyntax> = null;
  private attrs: Slice<AttributeSyntax> = null;

  static({ name, value }: { name: string, value: string }) {
    this.initBuffer('static').append(new Syntax.StaticAttr({ name: name as FIXME, value: value as FIXME }));
  }

  dynamic({ name, value }: { name: string, value: FunctionExpression }) {
    this.initBuffer('dynamic').append(new Syntax.DynamicAttr({ name: name as FIXME, value: makeFunctionExpression(value) }));
  }

  replace(attrs: Slice<AttributeSyntax>) {
    if (this.buffer) {
      throw new Error(`Cannot attrs.replace if you already did attrs.static or attrs.dynamic`);
    }

    this.attrs = attrs;
  }

  asSlice(): Slice<AttributeSyntax> {
    return this.attrs || this.buffer;
  }

  private initBuffer(operation: string): LinkedList<AttributeSyntax> {
    if (!this.buffer) {
      if (this.attrs) {
        this.buffer = LinkedList.fromSlice(this.attrs);
        this.attrs = null;
      } else {
        this.buffer = new LinkedList<AttributeSyntax>();
      }
    }

    return this.buffer;
  }
}

class ComponentBodyBuilder implements Component.ComponentBodyBuilder {
  private program: Slice<StatementSyntax> = null;

  fromLayout(layout: CompiledLayout) {
    this.program = layout.program;
  }

  replace(program: Slice<StatementSyntax>) {
    this.program = program;
  }

  asSlice(): Slice<StatementSyntax> {
    return this.program;
  }
}

export class LayoutCompiler extends Compiler {
  private preamble: CompileIntoList;
  private body: CompileIntoList;
  private definition: ComponentDefinition<any>;
  protected block: Layout;

  constructor(layout: Layout, env: Environment, definition: ComponentDefinition<any>) {
    super(layout, env);
    this.definition = definition;
  }

  compile(): CompiledComponentParts {
    let builder = new ComponentBuilder();

    let { block: layout, env, symbolTable } = this;
    this.definition.compile(builder, { env, symbolTable });

    let { tag, attrs, body } = builder.toParts();

    let preamble = this.preamble = new CompileIntoList(env, this.symbolTable);
    let main = this.body = new CompileIntoList(env, this.symbolTable);

    if (layout.hasNamedParameters()) {
      preamble.append(BindNamedArgsOpcode.create(layout));
    }

    if (layout.hasYields()) {
      preamble.append(BindBlocksOpcode.create(layout));
    }

    attrs.forEachNode(attr => {
      this.compileStatement(attr, preamble);
    });

    body.forEachNode(statement => {
      this.compileStatement(statement, main);
    });

    return { tag, preamble, main };
  }

  getLocalSymbol(name: InternedString): number {
    return this.symbolTable.getLocal(name);
  }

  getNamedSymbol(name: InternedString): number {
    return this.symbolTable.getNamed(name);
  }

  getBlockSymbol(name: InternedString): number {
    return this.symbolTable.getYield(name);
  }
}

interface OpenComponentOptions {
  definition: ComponentDefinition<any>;
  args: Args;
  shadow: InternedString[];
  templates: Templates;
}

export interface OpcodeBuilder {
  openComponent(options: OpenComponentOptions);
  closeComponent();
}

export class CompileIntoList extends LinkedList<Opcode> implements CompileInto, OpcodeBuilder {
  private env: Environment;
  private symbolTable: SymbolTable;

  constructor(env: Environment, symbolTable: SymbolTable) {
    super();
    this.env = env;
    this.symbolTable = symbolTable;
  }

  getLocalSymbol(name: InternedString): number {
    return this.symbolTable.getLocal(name);
  }

  getNamedSymbol(name: InternedString): number {
    return this.symbolTable.getNamed(name);
  }

  getBlockSymbol(name: InternedString): number {
    return this.symbolTable.getYield(name);
  }

  // implement OpcodeBuilder

  openComponent({ definition, args: rawArgs, shadow, templates }: OpenComponentOptions) {
    let args = rawArgs.compile(this, this.env);
    this.append(new OpenComponentOpcode({ definition, args, shadow, templates }));
  }

  closeComponent() {
    this.append(new CloseComponentOpcode());
  }
}