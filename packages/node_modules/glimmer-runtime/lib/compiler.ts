import { FIXME, Slice, LinkedList, InternedString, Dict, dict } from 'glimmer-util';
import { OpSeq, Opcode } from './opcodes';
import { CompiledExpression } from './compiled/expressions';
import { OpenPrimitiveElementOpcode, CloseElementOpcode } from './compiled/opcodes/dom';
import { PushDynamicScopeOpcode, PopDynamicScopeOpcode, BindKeywordsOpcode } from './compiled/opcodes/vm';
import { DidCreateElementOpcode, ShadowAttributesOpcode } from './compiled/opcodes/component';
import { BindNamedArgsOpcode, BindBlocksOpcode, BindPositionalArgsOpcode } from './compiled/opcodes/vm';
import { SymbolLookup } from './syntax';
import * as Syntax from './syntax/core';
import { Environment } from './environment';
import SymbolTable from './symbol-table';
import { Block, CompiledBlock, EntryPoint, InlineBlock, Layout } from './compiled/blocks';

import {
  OpenComponentOpcode,
  CloseComponentOpcode
} from './compiled/opcodes/component';

import {
  OpenComponentOptions
} from './opcode-builder';

import {
  Statement as StatementSyntax,
  Attribute as AttributeSyntax,
  StatementCompilationBuffer
} from './syntax';

import {
  FunctionExpression,
  default as makeFunctionExpression
} from './compiled/expressions/function';

import * as Component from './component/interfaces';
import { CACHED_LAYOUT } from './component/interfaces';

abstract class Compiler {
  public env: Environment;
  protected block: Block;
  protected symbolTable: SymbolTable;
  protected current: StatementSyntax;

  constructor(block: Block, env: Environment) {
    this.block = block;
    this.current = block.program.head();
    this.env = env;
    this.symbolTable = block.symbolTable;
  }

  protected compileStatement(statement: StatementSyntax, ops: StatementCompilationBuffer) {
    this.env.statement(statement).compile(ops, this.env);
  }
}

function compileStatement(env: Environment, statement: StatementSyntax, ops: StatementCompilationBuffer) {
  env.statement(statement).compile(ops, env);
}

export default Compiler;

export class EntryPointCompiler extends Compiler {
  private ops: StatementCompilationBuffer;
  protected block: EntryPoint;

  constructor(template: EntryPoint, env: Environment) {
    super(template, env);
    this.ops = new CompileIntoList(env, template.symbolTable);
  }

  compile(): OpSeq {
    let { block, ops } = this;
    let { program } = block;

    let current = program.head();

    while (current) {
      let next = program.nextNode(current);
      this.compileStatement(current, ops);
      current = next;
    }

    return ops.toOpSeq();
  }

  append(op: Opcode) {
    this.ops.append(op);
  }

  getLocalSymbol(name: InternedString): number {
    return this.symbolTable.getLocal(name);
  }

  getNamedSymbol(name: InternedString): number {
    return this.symbolTable.getNamed(name);
  }

  getYieldSymbol(name: InternedString): number {
    return this.symbolTable.getYield(name);
  }
}

export class InlineBlockCompiler extends Compiler {
  private ops: CompileIntoList;
  protected block: InlineBlock;
  protected current: StatementSyntax;

  constructor(block: InlineBlock, env: Environment) {
    super(block, env);
    this.ops = new CompileIntoList(env, block.symbolTable);
  }

  compile(): CompileIntoList {
    let { block, ops } = this;
    let { program } = block;

    if (block.hasPositionalParameters()) {
      ops.append(new BindPositionalArgsOpcode({ block }));
    }

    let current = program.head();

    while (current) {
      let next = program.nextNode(current);
      this.compileStatement(current, ops);
      current = next;
    }

    return ops;
  }
}

export interface ComponentParts {
  tag: InternedString;
  attrs: Slice<AttributeSyntax>;
  body: Slice<StatementSyntax>;
}

export interface CompiledComponentParts {
  tag: InternedString;
  preamble: CompileIntoList;
  main: CompileIntoList;
}

export function layoutFor(definition: Component.ComponentDefinition<any>, env: Environment): CompiledBlock {
  let layout = definition[CACHED_LAYOUT];
  if (layout) return layout;

  let builder = new ComponentLayoutBuilder(env);

  definition['compile'](builder);

  return definition[CACHED_LAYOUT] = builder.compile();
}

class ComponentLayoutBuilder implements Component.ComponentLayoutBuilder {
  public env: Environment;

  private inner: WrappedBuilder | UnwrappedBuilder;
  private keywords: Dict<FunctionExpression> = null;

  constructor(env: Environment) {
    this.env = env;
  }

  wrapLayout(layout: Layout) {
    this.inner = new WrappedBuilder(this.env, layout);
  }

  fromLayout(layout: Layout) {
    this.inner = new UnwrappedBuilder(this.env, layout);
  }

  bindKeywords(keywords: Dict<FunctionExpression>) {
    this.keywords = keywords;
  }

  compile(): CompiledBlock {
    return this.inner.compile(this.keywords);
  }

  get tag(): Component.ComponentTagBuilder {
    return this.inner.tag;
  }

  get attrs(): Component.ComponentAttrsBuilder {
    return this.inner.attrs;
  }
}

class WrappedBuilder {
  private layout: Layout;
  public env: Environment;

  public tag = new ComponentTagBuilder();
  public attrs = new ComponentAttrsBuilder();

  constructor(env: Environment, layout: Layout) {
    this.env = env;
    this.layout = layout;
  }

  compile(keywords: Dict<FunctionExpression>): CompiledBlock {
    let { env, layout } = this;

    let list = new CompileIntoList(env, layout.symbolTable);

    if (keywords) {
      list.append(new PushDynamicScopeOpcode());
      list.append(BindKeywordsOpcode.create(list, compileKeywords(list, this.env, keywords)));
    }

    if (layout.hasNamedParameters()) {
      list.append(BindNamedArgsOpcode.create(layout));
    }

    if (layout.hasYields()) {
      list.append(BindBlocksOpcode.create(layout));
    }

    let tag = this.tag['tagName'];

    list.append(new OpenPrimitiveElementOpcode({ tag }));

    list.append(new DidCreateElementOpcode());

    this.attrs['buffer'].forEach(statement => compileStatement(env, statement, list));

    layout.program.forEachNode(statement => compileStatement(env, statement, list));

    list.append(new CloseElementOpcode());

    if (keywords) {
      list.append(new PopDynamicScopeOpcode());
    }

    return new CompiledBlock(list, layout.symbolTable.size);
  }
}

class UnwrappedBuilder {
  private layout: Layout;
  public env: Environment;

  public attrs = new ComponentAttrsBuilder();

  constructor(env: Environment, layout: Layout) {
    this.env = env;
    this.layout = layout;
  }

  get tag(): Component.ComponentTagBuilder {
    throw new Error('BUG: Cannot call `tag` on an UnwrappedBuilder');
  }

  compile(keywords: Dict<FunctionExpression>): CompiledBlock {
    let { env, layout } = this;

    let list = new CompileIntoList(env, layout.symbolTable);

    if (keywords) {
      list.append(new PushDynamicScopeOpcode());
      list.append(BindKeywordsOpcode.create(list, compileKeywords(list, this.env, keywords)));
    }

    if (layout.hasNamedParameters()) {
      list.append(BindNamedArgsOpcode.create(layout));
    }

    if (layout.hasYields()) {
      list.append(BindBlocksOpcode.create(layout));
    }

    let attrs = this.attrs['buffer'];
    let attrsInserted = false;

    this.layout.program.forEachNode(statement => {
      compileStatement(env, statement, list);

      if (!attrsInserted && isOpenElement(statement)) {
        list.append(new DidCreateElementOpcode());
        list.append(new ShadowAttributesOpcode());
        attrs.forEach(statement => compileStatement(env, statement, list));
        attrsInserted = true;
      }
    });

    if (keywords) {
      list.append(new PopDynamicScopeOpcode());
    }

    return new CompiledBlock(list, layout.symbolTable.size);
  }
}

function compileKeywords(lookup: SymbolLookup, env: Environment, keywords: Dict<FunctionExpression>): Dict<CompiledExpression> {
  let compiledKeywords = dict<CompiledExpression>();

  Object.keys(keywords).forEach(k => {
    compiledKeywords[k] = makeFunctionExpression(keywords[k]).compile(lookup, env);
  });

  return compiledKeywords;
}

type OpenElement = Syntax.OpenElement | Syntax.OpenPrimitiveElement;

function isOpenElement(syntax: StatementSyntax): syntax is OpenElement {
  return syntax instanceof Syntax.OpenElement || syntax instanceof Syntax.OpenPrimitiveElement;
}

class ComponentTagBuilder implements Component.ComponentTagBuilder {
  private tagName: InternedString = null;

  static(tagName: InternedString) {
    this.tagName = tagName;
  }
}

class ComponentAttrsBuilder implements Component.ComponentAttrsBuilder {
  private buffer: AttributeSyntax[] = [];

  static(name: string, value: string) {
    this.buffer.push(new Syntax.StaticAttr({ name: name as FIXME, value: value as FIXME }));
  }

  dynamic(name: string, value: FunctionExpression) {
    this.buffer.push(new Syntax.DynamicAttr({ name: name as FIXME, value: makeFunctionExpression(value) }));
  }
}

class ComponentBodyBuilder implements Component.ComponentBodyBuilder {
  private layout: Layout = null;

  fromLayout(layout: Layout) {
    this.layout = layout;
  }
}

export class CompileIntoList extends LinkedList<Opcode> implements StatementCompilationBuffer {
  private env: Environment;
  private symbolTable: SymbolTable;
  private keywords = dict<number>();

  constructor(env: Environment, symbolTable: SymbolTable) {
    super();
    this.env = env;
    this.symbolTable = symbolTable;

    let keywords = this.keywords;
    env.getKeywords().forEach((n, i) => keywords[<string>n] = i);
  }

  getLocalSymbol(name: InternedString): number {
    return this.symbolTable.getLocal(name);
  }

  hasLocalSymbol(name: InternedString): boolean {
    return typeof this.symbolTable.getLocal(name) === 'number';
  }

  getNamedSymbol(name: InternedString): number {
    return this.symbolTable.getNamed(name);
  }

  hasNamedSymbol(name: InternedString): boolean {
    return typeof this.symbolTable.getNamed(name) === 'number';
  }

  getBlockSymbol(name: InternedString): number {
    return this.symbolTable.getYield(name);
  }

  hasBlockSymbol(name: InternedString): boolean {
    return typeof this.symbolTable.getYield(name) === 'number';
  }

  getKeywordSymbol(name: InternedString): number {
    return this.keywords[<string>name];
  }

  hasKeywordSymbol(name: InternedString): boolean {
    return typeof this.keywords[<string>name] === 'number';
  }

  toOpSeq(): OpSeq {
    return this;
  }

  // implement OpcodeBuilder

  openComponent({ definition, args: rawArgs, shadow, templates }: OpenComponentOptions) {
    let args = rawArgs.compile(this, this.env);
    this.append(new OpenComponentOpcode({ definition, args, shadow, templates }));
  }

  closeComponent() {
    this.append(new CloseComponentOpcode());
  }
}
