import { Slice, LinkedList, InternedString } from 'glimmer-util';
import { OpSeqBuilder, Opcode } from './opcodes';
import { BindNamedArgsOpcode, BindBlocksOpcode, BindPositionalArgsOpcode } from './compiled/opcodes/vm';
import { Statement as StatementSyntax, Attribute as AttributeSyntax, CompileInto } from './syntax';
import { Environment } from './environment';
import { ComponentDefinition } from './component/interfaces';
import SymbolTable from './symbol-table';
import { Block, EntryPoint, InlineBlock, Layout } from './compiled/blocks';
import { Args, Templates } from './syntax/core';
import {
  OpenComponentOpcode,
  CloseComponentOpcode
} from './compiled/opcodes/component';

abstract class Compiler {
  public env: Environment;
  protected block: Block;
  protected symbolTable: SymbolTable;
  protected current: StatementSyntax;

  constructor(block: Block, env: Environment) {
    this.block = block;
    this.current = block.program.head();
    this.env = env;
    this.symbolTable = block.symbolTable;
  }

  protected compileStatement(statement: StatementSyntax, ops: CompileIntoList) {
    this.env.statement(statement).compile(ops, this.env);
  }

}

export default Compiler;

export class EntryPointCompiler extends Compiler {
  private ops: CompileIntoList;
  protected block: EntryPoint;

  constructor(template: EntryPoint, env: Environment) {
    super(template, env);
    this.ops = new CompileIntoList(env, template.symbolTable);
  }

  compile(): OpSeqBuilder {
    let { block, ops } = this;
    let { program } = block;

    let current = program.head();

    while (current) {
      let next = program.nextNode(current);
      this.compileStatement(current, ops);
      current = next;
    }

    return ops;
  }

  append(op: Opcode) {
    this.ops.append(op);
  }

  getLocalSymbol(name: InternedString): number {
    return this.symbolTable.getLocal(name);
  }

  getNamedSymbol(name: InternedString): number {
    return this.symbolTable.getNamed(name);
  }

  getYieldSymbol(name: InternedString): number {
    return this.symbolTable.getYield(name);
  }
}

export class InlineBlockCompiler extends Compiler {
  private ops: CompileIntoList;
  protected block: InlineBlock;
  protected current: StatementSyntax;

  constructor(block: InlineBlock, env: Environment) {
    super(block, env);
    this.ops = new CompileIntoList(env, block.symbolTable);
  }

  compile(): CompileIntoList {
    let { block, ops } = this;
    let { program } = block;

    if (block.hasPositionalParameters()) {
      ops.append(new BindPositionalArgsOpcode({ block }));
    }

    let current = program.head();

    while (current) {
      let next = program.nextNode(current);
      this.compileStatement(current, ops);
      current = next;
    }

    return ops;
  }
}

export interface ComponentParts {
  tag: InternedString;
  attrs: Slice<AttributeSyntax>;
  body: Slice<StatementSyntax>;
}

export interface CompiledComponentParts {
  tag: InternedString;
  preamble: CompileIntoList;
  main: CompileIntoList;
}

export class LayoutCompiler extends Compiler {
  private preamble: CompileIntoList;
  private body: CompileIntoList;
  private definition: ComponentDefinition<any>;
  protected block: Layout;

  constructor(layout: Layout, env: Environment, definition: ComponentDefinition<any>) {
    super(layout, env);
    this.definition = definition;
  }

  compile(): CompiledComponentParts {
    let { block: layout, env, symbolTable } = this;
    let { tag, attrs, body } = this.definition.compile({ env, symbolTable });

    let preamble = this.preamble = new CompileIntoList(env, this.symbolTable);
    let main = this.body = new CompileIntoList(env, this.symbolTable);

    if (layout.hasNamedParameters()) {
      preamble.append(BindNamedArgsOpcode.create(layout));
    }

    if (layout.hasYields()) {
      preamble.append(BindBlocksOpcode.create(layout));
    }

    attrs.forEachNode(attr => {
      this.compileStatement(attr, preamble);
    });

    body.forEachNode(statement => {
      this.compileStatement(statement, main);
    });

    return { tag, preamble, main };
  }

  getLocalSymbol(name: InternedString): number {
    return this.symbolTable.getLocal(name);
  }

  getNamedSymbol(name: InternedString): number {
    return this.symbolTable.getNamed(name);
  }

  getBlockSymbol(name: InternedString): number {
    return this.symbolTable.getYield(name);
  }
}

interface OpenComponentOptions {
  definition: ComponentDefinition<any>;
  args: Args;
  shadow: InternedString[];
  templates: Templates;
}

export interface OpcodeBuilder {
  openComponent(options: OpenComponentOptions);
  closeComponent();
}

export class CompileIntoList extends LinkedList<Opcode> implements CompileInto, OpcodeBuilder {
  private env: Environment;
  private symbolTable: SymbolTable;

  constructor(env: Environment, symbolTable: SymbolTable) {
    super();
    this.env = env;
    this.symbolTable = symbolTable;
  }

  getLocalSymbol(name: InternedString): number {
    return this.symbolTable.getLocal(name);
  }

  getNamedSymbol(name: InternedString): number {
    return this.symbolTable.getNamed(name);
  }

  getBlockSymbol(name: InternedString): number {
    return this.symbolTable.getYield(name);
  }

  // implement OpcodeBuilder

  openComponent({ definition, args: rawArgs, shadow, templates }: OpenComponentOptions) {
    let args = rawArgs.compile(this, this.env);
    this.append(new OpenComponentOpcode({ definition, args, shadow, templates }));
  }

  closeComponent() {
    this.append(new CloseComponentOpcode());
  }
}