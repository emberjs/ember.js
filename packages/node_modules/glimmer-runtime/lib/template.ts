import { InternedString, Opaque, Dict } from 'glimmer-util';
import { SerializedTemplate } from 'glimmer-wire-format';
import { PathReference } from 'glimmer-reference';
import { EntryPoint, Layout } from './compiled/blocks';
import { Environment, DynamicScope } from './environment';
import { ElementStack } from './builder';
import VM from './vm/append';
import Scanner from './scanner';

interface TemplateOptions {
  raw: EntryPoint;
}

interface RenderOptions {
  hostOptions?: Object;
  keywords?: Dict<PathReference<Opaque>>;
  appendTo: Element;
}

interface EvaluateOptions {
  nextSibling?: Node;
}

export default class Template {
  static fromSpec(spec: SerializedTemplate, env: Environment): Template {
    let scanner = new Scanner(spec, env);
    return new Template({
      raw: scanner.scanEntryPoint()
    });
  }

  static layoutFromSpec(spec: SerializedTemplate, env: Environment): Layout {
    let scanner = new Scanner(spec, env);
    return scanner.scanLayout();
  }

  raw: EntryPoint;
  meta: Object;

  constructor({ raw }: TemplateOptions) {
    this.raw = raw;
  }

  render(self: PathReference<any>, env: Environment, { keywords, appendTo }: RenderOptions, blockArguments: any[]=null) {
    let elementStack = ElementStack.forInitialRender({ dom: env.getDOM(), parentNode: appendTo, nextSibling: null });
    let compiled = this.raw.compile(env);
    let vm = VM.initial(env, { self, elementStack, size: compiled.symbols });

    if (keywords) {
      bindSymbols(vm.dynamicScope(), env, keywords);
    }

    return vm.execute(compiled.ops);
  }
}

function bindSymbols(scope: DynamicScope, env: Environment, dict: Dict<PathReference<Opaque>>) {
  let toBind = Object.keys(dict);
  let keywords = env.getKeywords();

  toBind.forEach(k => {
    scope.bindSymbol(keywords.indexOf(k as InternedString), dict[k]);
  });
}
