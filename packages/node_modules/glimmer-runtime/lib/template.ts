import { InternedString, Opaque, Dict } from 'glimmer-util';
import { SerializedTemplate } from 'glimmer-wire-format';
import { PathReference } from 'glimmer-reference';
import { EntryPoint, Layout } from './compiled/blocks';
import { Environment, DynamicScope } from './environment';
import { ElementStack } from './builder';
import { VM, BindDynamicScopeCallback } from './vm';
import Scanner from './scanner';

interface TemplateOptions {
  raw: EntryPoint;
}

interface RenderOptions {
  hostOptions?: Object;
  dynamicScope?: BindDynamicScopeCallback;
  appendTo: Element;
}

interface EvaluateOptions {
  nextSibling?: Node;
}

export default class Template {
  static fromSpec(spec: SerializedTemplate, env: Environment): Template {
    let scanner = new Scanner(spec, env);
    return new Template({
      raw: scanner.scanEntryPoint()
    });
  }

  static layoutFromSpec(spec: SerializedTemplate, env: Environment): Layout {
    let scanner = new Scanner(spec, env);
    return scanner.scanLayout();
  }

  raw: EntryPoint;
  meta: Object;

  constructor({ raw }: TemplateOptions) {
    this.raw = raw;
  }

  render(self: PathReference<any>, env: Environment, { dynamicScope, appendTo }: RenderOptions, blockArguments: any[]=null) {
    let elementStack = ElementStack.forInitialRender({ dom: env.getDOM(), parentNode: appendTo, nextSibling: null });
    let compiled = this.raw.compile(env);
    let vm = VM.initial(env, { self, elementStack, size: compiled.symbols });

    if (dynamicScope) {
      vm.bindDynamicScope(dynamicScope);
    }

    return vm.execute(compiled.ops);
  }
}
