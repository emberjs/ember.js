import { Scope, Environment } from '../environment';
import { Bounds, clear, move } from '../bounds';
import { ElementStack } from '../builder';
import { ComponentDefinition } from '../component/interfaces';
import { Stack, LinkedList, LOGGER, InternedString, Dict, dict, assert } from 'glimmer-util';
import { ConstReference, ChainableReference, PathReference, RootReference, ListManager, ListIterator, ListDelegate } from 'glimmer-reference';
import Template from '../template';
import { Templates } from '../syntax/core';
import { InlineBlock as CompiledInlineBlock } from '../compiled/blocks';
import { CompiledExpression } from '../compiled/expressions';
import { CompiledArgs, EvaluatedArgs } from '../compiled/expressions/args';
import { Opcode, OpSeq, UpdatingOpcode, UpdatingOpSeq } from '../opcodes';
import { LabelOpcode } from '../compiled/opcodes/vm';
import { Range } from '../utils';
import DOMHelper from '../dom';


class Frame {
  ops: OpSeq;
  op: Opcode;
  operand: PathReference = null;
  args: EvaluatedArgs = null;
  callerScope: Scope = null;
  blocks: Blocks = null;
  condition: ChainableReference = null;
  iterator: ListIterator = null;
  key: InternedString = null;

  constructor(ops: OpSeq) {
    this.ops = ops;
    this.op = ops.head();
  }
}

export interface Blocks {
  default: CompiledInlineBlock;
  inverse: CompiledInlineBlock;
}

export class FrameStack {
  private frames: Frame[] = [];
  private frame: number = undefined;

  push(ops: OpSeq) {
    let frame = (this.frame === undefined) ? (this.frame = 0) : ++this.frame;

    if (this.frames.length <= frame) {
      this.frames.push(null);
    }

    this.frames[frame] = new Frame(ops);
  }

  pop() {
    let { frames, frame } = this;
    frames[frame] = null;
    this.frame = frame === 0 ? undefined : frame - 1;
  }

  getOps(): OpSeq {
    return this.frames[this.frame].ops;
  }

  getCurrent(): Opcode {
    return this.frames[this.frame].op;
  }

  setCurrent(op: Opcode): Opcode {
    return this.frames[this.frame].op = op;
  }

  getOperand(): PathReference {
    return this.frames[this.frame].operand;
  }

  setOperand(operand: PathReference): PathReference {
    return this.frames[this.frame].operand = operand;
  }

  getArgs(): EvaluatedArgs {
    return this.frames[this.frame].args;
  }

  setArgs(args: EvaluatedArgs): EvaluatedArgs {
    return this.frames[this.frame].args = args;
  }

  getCondition(): ChainableReference {
    return this.frames[this.frame].condition;
  }

  setCondition(condition: ChainableReference): ChainableReference {
    return this.frames[this.frame].condition = condition;
  }

  getIterator(): ListIterator {
    return this.frames[this.frame].iterator;
  }

  setIterator(iterator: ListIterator): ListIterator {
    return this.frames[this.frame].iterator = iterator;
  }

  getKey(): InternedString {
    return this.frames[this.frame].key;
  }

  setKey(key: InternedString): InternedString {
    return this.frames[this.frame].key = key;
  }

  getBlocks(): Blocks {
    return this.frames[this.frame].blocks;
  }

  setBlocks(blocks: Blocks): Blocks {
    return this.frames[this.frame].blocks = blocks;
  }

  getCallerScope(): Scope {
    return this.frames[this.frame].callerScope;
  }

  setCallerScope(callerScope: Scope): Scope {
    return this.frames[this.frame].callerScope = callerScope;
  }

  goto(op: LabelOpcode) {
    this.setCurrent(op);
  }

  hasOpcodes(): boolean {
    return this.frame !== undefined;
  }

  nextStatement(): Opcode {
    let op = this.frames[this.frame].op;
    let ops = this.getOps();

    if (op) {
      this.setCurrent(ops.nextNode(op));
      return op;
    } else {
      this.pop();
      return null;
    }
  }
}