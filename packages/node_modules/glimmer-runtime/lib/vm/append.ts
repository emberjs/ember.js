import { Scope, Environment } from '../environment';
import { Bounds, clear, move } from '../bounds';
import { ElementStack } from '../builder';
import { ComponentDefinition } from '../component/interfaces';
import { Stack, LinkedList, LOGGER, InternedString, Dict, dict, assert } from 'glimmer-util';
import { ConstReference, ChainableReference, PathReference, RootReference, ListManager, ListIterator, ListDelegate } from 'glimmer-reference';
import Template from '../template';
import { Templates } from '../syntax/core';
import { Block as CompiledBlock, InlineBlock as CompiledInlineBlock } from '../compiled/blocks';
import { CompiledExpression } from '../compiled/expressions';
import { CompiledArgs, EvaluatedArgs } from '../compiled/expressions/args';
import { Opcode, OpSeq, UpdatingOpcode, UpdatingOpSeq } from '../opcodes';
import { LabelOpcode } from '../compiled/opcodes/vm';
import { Range } from '../utils';
import DOMHelper from '../dom';

import UpdatingVM, { ListBlockOpcode, TryOpcode, BlockOpcode } from './update';
import RenderResult from './render-result';
import { FrameStack, Blocks } from './frame';

interface VMOptions {
  self: RootReference;
  elementStack: ElementStack;
  size: number;
}

interface Registers {
  operand: PathReference;
  args: EvaluatedArgs;
  condition: ChainableReference;
  iterator: ListIterator;
  key: InternedString;
  templates: Dict<Template>;
}

interface InvokeLayoutOptions {
  args: EvaluatedArgs;
  shadow: InternedString[];
  definition: ComponentDefinition;
  templates: Templates;
  callerScope: Scope;
}

interface PushFrameOptions {
  block: CompiledBlock;
  args?: EvaluatedArgs;
  blocks?: Blocks;
  callerScope?: Scope;
}

type OpList = Range<Opcode>;

export default class VM {
  public env: Environment;
  private scopeStack = new Stack<Scope>();
  private elementStack: ElementStack;
  public updatingOpcodeStack = new Stack<LinkedList<UpdatingOpcode>>();
  public listBlockStack = new Stack<ListBlockOpcode>();
  public frame = new FrameStack();

  static initial(env: Environment, { elementStack, self, size }: VMOptions) {
    let scope = env.createRootScope(size).init({ self });
    return new VM(env, scope, elementStack);
  }

  constructor(env: Environment, scope: Scope, elementStack: ElementStack) {
    this.env = env;
    this.elementStack = elementStack;
    this.scopeStack.push(scope);
  }

  goto(op: LabelOpcode) {
    // assert(this.frame.getOps().contains(op), `Illegal jump to ${op.label}`);
    this.frame.goto(op);
  }

  enter(ops: OpSeq) {
    this.stack().startBounds();

    let updating = new LinkedList<UpdatingOpcode>();

    let tryOpcode = new TryOpcode({ ops, vm: this, updating });

    this.didEnter(tryOpcode, updating);
  }

  enterWithKey(key: InternedString, ops: OpSeq) {
    this.stack().startBounds();

    let updating = new LinkedList<UpdatingOpcode>();

    let tryOpcode = new TryOpcode({ ops, vm: this, updating });

    this.listBlockStack.current.map[<string>key] = tryOpcode;

    this.didEnter(tryOpcode, updating);
  }

  enterList(manager: ListManager, ops: OpSeq) {
    let updating = new LinkedList<BlockOpcode>();
    this.stack().openBlockList(updating);

    let opcode = new ListBlockOpcode({ ops, vm: this, updating, manager });

    this.listBlockStack.push(opcode);

    this.didEnter(opcode, updating);
  }

  private didEnter(opcode: BlockOpcode, updating: LinkedList<UpdatingOpcode>) {
    this.updateWith(opcode);
    this.updatingOpcodeStack.push(updating);
  }

  exit() {
    this.stack().finishBounds();
    this.updatingOpcodeStack.pop();
  }

  exitList() {
    this.exit();
    this.listBlockStack.pop();
  }

  updateWith(opcode: UpdatingOpcode) {
    this.updatingOpcodeStack.current.insertBefore(opcode, null);
  }

  stack(): ElementStack {
    return this.elementStack;
  }

  scope(): Scope {
    return this.scopeStack.current;
  }

  pushFrame({ block, args, blocks, callerScope }: PushFrameOptions) {
    this.frame.push(block.ops);

    if (args) this.frame.setArgs(args);
    if (blocks) this.frame.setBlocks(blocks);
    if (callerScope) this.frame.setCallerScope(callerScope);
  }

  popFrame() {
    let { frame } = this;

    frame.pop();
    let current = frame.getCurrent();

    if (current === null) return;
  }

  pushChildScope() {
    this.scopeStack.push(this.scopeStack.current.child());
  }

  pushCallerScope() {
    this.scopeStack.push(this.scope().getCallerScope());
  }

  pushRootScope(size: number): Scope {
    let scope = this.env.createRootScope(size);
    this.scopeStack.push(scope);
    return scope;
  }

  popScope() {
    this.scopeStack.pop();
  }

  /// SCOPE HELPERS

  getSelf() {
    return this.scope().getSelf();
  }

  referenceForSymbol(symbol: number) {
    return this.scope().getSymbol(symbol);
  }

  /// EXECUTION

  execute(opcodes: OpSeq, initialize?: (vm: VM) => void): RenderResult {
    LOGGER.debug("[VM] Begin program execution");

    let { elementStack, frame, updatingOpcodeStack, env } = this;
    let self = this.scope().getSelf();

    elementStack.startBounds();

    updatingOpcodeStack.push(new LinkedList<UpdatingOpcode>());
    frame.push(opcodes);

    if (initialize) initialize(this);

    let opcode: Opcode;

    while (frame.hasOpcodes()) {
      if (opcode = frame.nextStatement()) {
        LOGGER.debug(`[VM] OP ${opcode.type}`);
        LOGGER.trace(opcode);
        opcode.evaluate(this);
      }
    }

    LOGGER.debug("[VM] Completed program execution");

    return new RenderResult(updatingOpcodeStack.pop(), elementStack.finishBounds(), env.getDOM(), self);
  }

  evaluateOpcode(opcode: Opcode) {
    opcode.evaluate(this);
  }

  // Make sure you have opcodes that push and pop a scope around this opcode
  // if you need to change the scope.
  invokeBlock(block: CompiledInlineBlock, args: EvaluatedArgs) {
    block.compile(this.env);
    this.pushFrame({ block, args });
  }

  invokeLayout({ shadow, args, definition, templates, callerScope }: InvokeLayoutOptions) {
    let layout = definition.layout;
    layout.compile(definition, this.env);

    this.pushFrame({ block: layout, blocks: templates, callerScope, args });
  }

  evaluateOperand(expr: CompiledExpression) {
    this.frame.setOperand(expr.evaluate(this));
  }

  evaluateArgs(args: CompiledArgs) {
    let evaledArgs = this.frame.setArgs(args.evaluate(this));
    this.frame.setOperand(evaledArgs.positional.at(0));
  }

  bindPositionalArgs(entries: number[]) {
    let args = this.frame.getArgs();
    if (!args) return;

    let { positional } = args;

    let scope = this.scope();

    for(let i=0; i < entries.length; i++) {
      scope.bindSymbol(entries[i], positional.at(i));
    }
  }

  bindNamedArgs(entries: Dict<number>) {
    let args = this.frame.getArgs();
    if (!args) return;

    let { named } = args;

    let keys = Object.keys(entries);
    let scope = this.scope();

    for(let i=0; i < keys.length; i++) {
      scope.bindSymbol(entries[keys[i]], named.get(<InternedString>keys[i]));
    }
  }

  bindBlocks(entries: Dict<number>) {
    let blocks = this.frame.getBlocks();
    let callerScope = this.frame.getCallerScope();

    let scope = this.scope();

    scope.bindCallerScope(callerScope);

    Object.keys(entries).forEach(name => {
      scope.bindBlock(entries[name], (blocks && blocks[name]) || MISSING_BLOCK);
    });
  }
}

function MISSING_BLOCK() {}

interface ExceptionHandler {
  handleException(initialize?: (vm: VM) => void);
}

interface ReturnHandler {
  setRenderResult(renderResult: RenderResult);
}