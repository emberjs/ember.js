import { Scope, Environment } from '../environment';
import { Bounds, clear, move } from '../bounds';
import { ElementStack } from '../builder';
import { ComponentDefinition } from '../component/interfaces';
import { Stack, LinkedList, LOGGER, InternedString, Dict, dict, assert } from 'glimmer-util';
import { ConstReference, ChainableReference, PathReference, RootReference, ListManager, ListIterator, ListDelegate } from 'glimmer-reference';
import Template from '../template';
import { Templates } from '../syntax/core';
import { InlineBlock as CompiledInlineBlock } from '../compiled/blocks';
import { CompiledExpression } from '../compiled/expressions';
import { CompiledArgs, EvaluatedArgs } from '../compiled/expressions/args';
import { Opcode, OpSeq, UpdatingOpcode, UpdatingOpSeq } from '../opcodes';
import { LabelOpcode } from '../compiled/opcodes/vm';
import { Range } from '../utils';
import DOMHelper from '../dom';

import VM from './append';

export default class UpdatingVM {
  private frameStack: Stack<UpdatingVMFrame> = new Stack<UpdatingVMFrame>();
  public dom: DOMHelper;

  constructor(dom: DOMHelper) {
    this.dom = dom;
  }

  execute(opcodes: UpdatingOpSeq, handler: ExceptionHandler) {
    let { frameStack } = this;

    this.try(opcodes, handler);

    while (true) {
      if (frameStack.isEmpty()) break;

      let opcode = this.frameStack.current.nextStatement();

      if (opcode === null) {
        this.frameStack.pop();
        continue;
      }

      opcode.evaluate(this);
    }
  }

  try(ops: UpdatingOpSeq, handler: ExceptionHandler) {
    this.frameStack.push(new UpdatingVMFrame(this, ops, handler));
  }

  throw(initialize?: (vm: VM) => void) {
    this.frameStack.current.handleException(initialize);
  }

  evaluateOpcode(opcode: UpdatingOpcode) {
    opcode.evaluate(this);
  }
}

export interface ExceptionHandler {
  handleException(initialize?: (vm: VM) => void);
}

export interface BlockOpcodeOptions {
  ops: OpSeq;
  vm: VM;
  updating: LinkedList<UpdatingOpcode>;
}

export abstract class BlockOpcode implements UpdatingOpcode, Bounds {
  public type = "block";
  public next = null;
  public prev = null;

  protected env: Environment;
  protected scope: Scope;
  protected updating: LinkedList<UpdatingOpcode>;
  protected bounds: Bounds;
  public ops: OpSeq;

  constructor({ ops, vm, updating }: BlockOpcodeOptions) {
    this.ops = ops;
    this.updating = updating;
    this.env = vm.env;
    this.scope = vm.scope();
    this.bounds = vm.stack().block();
  }

  parentElement() {
    return this.bounds.parentElement();
  }

  firstNode() {
    return this.bounds.firstNode();
  }

  lastNode() {
    return this.bounds.lastNode();
  }

  evaluate(vm: UpdatingVM) {
    vm.try(this.updating, null);
  }
}

export class TryOpcode extends BlockOpcode implements UpdatingOpcode, ExceptionHandler {
  public type = "try";

  evaluate(vm: UpdatingVM) {
    vm.try(this.updating, this);
  }

  handleException(initialize?: (vm: VM) => void) {
    let stack = new ElementStack({
      dom: this.env.getDOM(),
      parentNode: this.bounds.parentElement(),
      nextSibling: initialize ? this.bounds.lastNode().nextSibling : clear(this.bounds)
    });

    let vm = new VM(this.env, this.scope, stack);
    let result = vm.execute(this.ops, initialize);

    if (!initialize) {
      this.updating = result.opcodes();
    }

    this.bounds = result;
  }
}

export class ListRevalidationDelegate implements ListDelegate {
  private opcode: ListBlockOpcode;
  private map: Dict<BlockOpcode>;
  private updating: LinkedList<UpdatingOpcode>;

  constructor(opcode: ListBlockOpcode) {
    let { map, updating } = opcode;
    this.opcode = opcode;
    this.map = map;
    this.updating = updating;
  }

  insert(key: InternedString, item: RootReference, before: InternedString) {
    let { map, opcode, updating } = this;
    let nextSibling: Node = null;
    let reference = null;

    if (before) {
      reference = map[<string>before];
      nextSibling = reference.bounds.firstNode();
    }

    let vm = opcode.vmForInsertion(nextSibling);
    let tryOpcode;

    vm.execute(opcode.ops, vm => {
      vm.frame.setArgs(EvaluatedArgs.positional([item]));
      vm.frame.setOperand(item);
      vm.frame.setCondition(new ConstReference(true));
      vm.frame.setKey(key);

      tryOpcode = new TryOpcode({
        vm,
        ops: opcode.ops,
        updating: vm.updatingOpcodeStack.current
      });
    });

    updating.insertBefore(tryOpcode, reference);

    map[<string>key] = tryOpcode;
  }

  retain(key: InternedString, item: RootReference) {
  }

  move(key: InternedString, item: RootReference, before: InternedString) {
    let { map, updating } = this;

    let entry = map[<string>key];
    let reference = map[<string>before] || null;

    if (before) {
      move(entry, reference.firstNode());
    } else {
      move(entry, this.opcode.lastNode());
    }

    updating.remove(entry);
    updating.insertBefore(entry, reference);
  }

  delete(key: InternedString) {
    let { map } = this;
    let opcode = map[<string>key];
    clear(opcode);
    this.updating.remove(opcode);
    delete map[<string>key];
  }

  done() {
    // this.vm.registers.condition = new ConstReference(false);
  }
}

export interface ListBlockOpcodeOptions extends BlockOpcodeOptions {
  manager: ListManager;
}

export class ListBlockOpcode extends BlockOpcode {
  public type = "list-block";
  public map = dict<BlockOpcode>();
  public manager: ListManager;

  constructor(options: ListBlockOpcodeOptions) {
    super(options);
    this.manager = options.manager;
  }

  firstNode(): Node {
    let head: BlockOpcode = <any>this.updating.head();

    if (head) {
      return head.firstNode();
    } else {
      return this.lastNode();
    }
  }

  lastNode(): Node {
    return this.bounds.lastNode();
  }

  evaluate(vm: UpdatingVM) {
    // Revalidate list somehow....
    let delegate = new ListRevalidationDelegate(this);

    this.manager.sync(delegate);

    // Run now-updated updating opcodes
    super.evaluate(vm);
  }

  vmForInsertion(nextSibling?: Node) {
    let stack = new ElementStack({
      dom: this.env.getDOM(),
      parentNode: this.bounds.parentElement(),
      nextSibling: nextSibling || this.bounds.lastNode()
    });

    return new VM(this.env, this.scope, stack);
  }
}

export class UpdatingVMFrame {
  private vm: UpdatingVM;
  private ops: UpdatingOpSeq;
  private current: UpdatingOpcode;
  private exceptionHandler: ExceptionHandler;

  constructor(vm: UpdatingVM, ops: UpdatingOpSeq, handler: ExceptionHandler) {
    this.vm = vm;
    this.ops = ops;
    this.current = ops.head();
    this.exceptionHandler = handler;
  }

  nextStatement(): UpdatingOpcode {
    let { current, ops } = this;
    if (current) this.current = ops.nextNode(current);
    return current;
  }

  handleException(initialize?: (vm: VM) => void) {
    this.exceptionHandler.handleException(initialize);
  }
}