import { EvaluatedNamedArgs } from '../compiled/expressions/args';
import { FunctionExpression } from '../compiled/expressions/function';

import { Layout as CompiledLayout } from '../compiled/blocks';

import Environment from '../environment';
import SymbolTable from '../symbol-table';

import * as Syntax from '../syntax';

import { Slice, InternedString } from 'glimmer-util';

export interface Component {};
export interface ComponentClass {};

export interface ComponentManager<T extends Component> {
  create(definition: ComponentDefinition<T>, attrs: EvaluatedNamedArgs): T;
  didCreate(component: T);

  update(component: T, attrs: EvaluatedNamedArgs);
  didUpdate(component: T);

  getSelf(component: T): any;
}

export interface ComponentBuilder {
  body: ComponentBodyBuilder;
  attrs: ComponentAttrsBuilder;

  tag(tagName: InternedString);
}

export interface ComponentAttrsBuilder {
  static(options: { name: string, value: string });
  dynamic(options: { name: string, value: FunctionExpression });
  replace(attrs: Slice<Syntax.Attribute>);
}

export interface ComponentBodyBuilder {
  fromLayout(layout: CompiledLayout);
  replace(statements: Slice<Syntax.Statement>);
}

export abstract class ComponentDefinition<T extends Component> {
  public name: string; // for debugging
  public manager: ComponentManager<T>;
  public ComponentClass: ComponentClass;

  constructor(name: string, manager: ComponentManager<T>, ComponentClass: ComponentClass) {
    this.name = name;
    this.manager = manager;
    this.ComponentClass = ComponentClass;
  }

  abstract getLayout(env: Environment): CompiledLayout;

  abstract compile(builder: ComponentBuilder, options: { env: Environment, symbolTable: SymbolTable });
}