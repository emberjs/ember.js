import {
  // VM
  VM,

  // Brands
  isAttribute,

  // Blocks
  CompiledLayout,

  // Compiler
  SymbolTable,
  CompileInto,

  // Environment
  Environment,
  DOMHelper,
  IDOMHepler,

  // Opcodes
  Opcode,
  LabelOpcode,
  EnterOpcode,
  EnterListOpcode,
  EnterWithKeyOpcode,
  ExitOpcode,
  ExitListOpcode,
  EvaluateOpcode,
  PushChildScopeOpcode,
  PopScopeOpcode,
  PutArgsOpcode,
  TestOpcode,
  JumpOpcode,
  JumpUnlessOpcode,
  NextIterOpcode,
  OpenComponentOpcode,
  CloseComponentOpcode,
  OpenPrimitiveElementOpcode,
  CloseElementOpcode,

  // Components
  Component,
  ComponentClass,
  ComponentManager,
  ComponentDefinition,
  EvaluatedNamedArgs,

  // Syntax Classes
  StatementSyntax,
  ExpressionSyntax,
  AttributeSyntax,

  // Concrete Syntax
  Templates,
  Append,
  Unknown,
  ArgsSyntax,
  NamedArgsSyntax,
  HelperSyntax,
  BlockSyntax,
  OpenElement as OpenElementSyntax,
  OpenPrimitiveElementSyntax,
  CloseElementSyntax,
  StaticAttr,
  DynamicAttr,
  ValueSyntax,
  RefSyntax,
  GetNamedParameterSyntax,

  // Compiled Syntax
  CompiledExpression,

  // References
  ValueReference
} from "glimmer-runtime";

import { compile as rawCompile, compileLayout as rawCompileLayout } from "./helpers";
import { FIXME, LinkedList, Slice, ListSlice, Dict, InternedString, assign, dict, intern } from 'glimmer-util';

import GlimmerObject, { GlimmerObjectFactory } from "glimmer-object";

import { Meta } from "glimmer-reference";

export type Attrs = Dict<any>;
type AttrsDiff = { oldAttrs: Attrs, newAttrs: Attrs };

export class BasicComponent implements Component {
  public attrs: Attrs;

  constructor(attrs: Attrs) {
    this.attrs = attrs;
  }
}

export class EmberishCurlyComponent extends GlimmerObject implements Component {
  public attrs: Attrs;
  public parentView: Component = null;

  static create(args: { attrs: Attrs }): EmberishCurlyComponent {
    return super.create(args) as EmberishCurlyComponent;
  }

  didInitAttrs({ attrs } : { attrs : Attrs }) {}
  didUpdateAttrs({ oldAttrs, newAttrs } : AttrsDiff) {}
  didReceiveAttrs({ oldAttrs, newAttrs } : AttrsDiff) {}
  willInsertElement() {}
  willUpdate() {}
  willRender() {}
  didInsertElement() {}
  didUpdate() {}
  didRender() {}
}

export class EmberishGlimmerComponent extends GlimmerObject implements Component {
  public attrs: Attrs;
  public parentView: Component = null;

  static create(args: { attrs: Attrs }): EmberishGlimmerComponent {
    return super.create(args) as EmberishGlimmerComponent;
  }

  didInitAttrs({ attrs } : { attrs : Attrs }) {}
  didUpdateAttrs({ oldAttrs, newAttrs } : AttrsDiff) {}
  didReceiveAttrs({ oldAttrs, newAttrs } : AttrsDiff) {}
  willInsertElement() {}
  willUpdate() {}
  willRender() {}
  didInsertElement() {}
  didUpdate() {}
  didRender() {}
}

class BasicComponentManager implements ComponentManager<BasicComponent> {
  create(definition: BasicComponentDefinition, args: EvaluatedNamedArgs): BasicComponent {
    let klass = definition.ComponentClass || BasicComponent;
    return new klass(args.value());
  }

  didCreate() {}

  update(component: BasicComponent, attrs: EvaluatedNamedArgs) {
    component.attrs = attrs.value();
  }

  didUpdate() {}

  getSelf(component: BasicComponent) {
    return component;
  }
}

const BASIC_COMPONENT_MANAGER = new BasicComponentManager();

const BaseEmberishGlimmerComponent = EmberishGlimmerComponent.extend() as typeof EmberishGlimmerComponent;

class EmberishGlimmerComponentManager implements ComponentManager<EmberishGlimmerComponent> {
  create(definition: EmberishGlimmerComponentDefinition, args: EvaluatedNamedArgs): EmberishGlimmerComponent {
    let klass = definition.ComponentClass || BaseEmberishGlimmerComponent;
    let attrs = args.value();
    let component = klass.create({ attrs });

    component.didInitAttrs({ attrs });
    component.didReceiveAttrs({ oldAttrs: null, newAttrs: attrs });
    component.willInsertElement();
    component.willRender();

    return component;
  }

  didCreate(component: EmberishGlimmerComponent) {
    component.didInsertElement();
    component.didRender();
  }

  update(component: EmberishGlimmerComponent, args: EvaluatedNamedArgs) {
    let oldAttrs = component.attrs;
    let newAttrs = args.value();

    component.set('attrs', newAttrs);
    component.didUpdateAttrs({ oldAttrs, newAttrs });
    component.didReceiveAttrs({ oldAttrs, newAttrs });
    component.willUpdate();
    component.willRender();
  }

  didUpdate(component: EmberishGlimmerComponent) {
    component.didUpdate();
    component.didRender();
  }

  getSelf(component: EmberishGlimmerComponent) {
    return component;
  }
}

const EMBERISH_GLIMMER_COMPONENT_MANAGER = new EmberishGlimmerComponentManager();

const BaseEmberishCurlyComponent = EmberishCurlyComponent.extend() as typeof EmberishCurlyComponent;

class EmberishCurlyComponentManager implements ComponentManager<EmberishCurlyComponent> {
  create(definition: EmberishCurlyComponentDefinition, args: EvaluatedNamedArgs): EmberishCurlyComponent {
    let klass = definition.ComponentClass || BaseEmberishCurlyComponent;
    let attrs = args.value();
    let merged = assign({}, attrs, { attrs });
    let component = klass.create(merged);

    component.didInitAttrs({ attrs });
    component.didReceiveAttrs({ oldAttrs: null, newAttrs: attrs });
    component.willInsertElement();
    component.willRender();

    return component;
  }

  didCreate(component: EmberishCurlyComponent) {
    component.didInsertElement();
    component.didRender();
  }

  update(component: EmberishCurlyComponent, args: EvaluatedNamedArgs) {
    let oldAttrs = component.attrs;
    let newAttrs = args.value();
    let merged = assign({}, newAttrs, { attrs: newAttrs });

    component.setProperties(merged);
    component.didUpdateAttrs({ oldAttrs, newAttrs });
    component.didReceiveAttrs({ oldAttrs, newAttrs });
    component.willUpdate();
    component.willRender();
  }

  didUpdate(component: EmberishCurlyComponent) {
    component.didUpdate();
    component.didRender();
  }

  getSelf(component: EmberishCurlyComponent) {
    return component;
  }
}

const EMBERISH_CURLY_COMPONENT_MANAGER = new EmberishCurlyComponentManager();

export class TestEnvironment extends Environment {
  private helpers = {};
  private components = dict<ComponentDefinition<any>>();

  constructor(dom?: IDOMHepler) {
    super(dom || new DOMHelper(document), Meta);

    this.registerHelper("if", ([cond, yes, no]) => cond ? yes : no);
    this.registerHelper("unless", ([cond, yes, no]) => cond ? no : yes);
  }

  registerHelper(name, helper) {
    this.helpers[name] = helper;
  }

  registerComponent(name: string, definition: ComponentDefinition<any>) {
    this.components[name] = definition;
    return definition;
  }

  registerBasicComponent<T extends BasicComponent>(name: string, Component: BasicComponentFactory, layout: string): ComponentDefinition<BasicComponentDefinition> {
    let definition = new BasicComponentDefinition(name, BASIC_COMPONENT_MANAGER, Component, layout);
    return this.registerComponent(name, definition);
  }

  registerEmberishCurlyComponent(name: string, Component: ComponentClass, layout: string): ComponentDefinition<EmberishCurlyComponentDefinition> {
    let definition = new EmberishCurlyComponentDefinition(name, EMBERISH_CURLY_COMPONENT_MANAGER, Component, layout);
    return this.registerComponent(name, definition);
  }

  registerEmberishGlimmerComponent(name: string, Component: EmberishGlimmerComponentFactory, layout: string): ComponentDefinition<EmberishGlimmerComponentDefinition> {
    let definition = new EmberishGlimmerComponentDefinition(name, EMBERISH_GLIMMER_COMPONENT_MANAGER, Component, layout);
    return this.registerComponent(name, definition);
  }

  statement<Options>(statement: StatementSyntax): StatementSyntax {
    let type = statement.type;
    let block = type === 'block' ? <BlockSyntax>statement : null;
    let append = type === 'append' ? <Append>statement : null;

    let named: NamedArgsSyntax;
    let args: ArgsSyntax;
    let path: InternedString[];
    let unknown: Unknown;
    let helper: HelperSyntax;

    if (block) {
      args = block.args;
      named = args.named;
      path = block.path;
    } else if (append && append.value.type === 'unknown') {
      unknown = <Unknown>append.value;
      args = ArgsSyntax.empty();
      named = NamedArgsSyntax.empty();
      path = unknown.ref.path();
    } else if (append && append.value.type === 'helper') {
      helper = <HelperSyntax>append.value;
      args = helper.args;
      named = args.named;
      path = helper.ref.path();
    }

    let key: InternedString, isSimple: boolean;

    if (path) {
      isSimple = path.length === 1;
      key = path[0];
    }

    if (isSimple && block) {
      switch (key) {
        case 'identity':
          return new IdentitySyntax({ args: block.args, templates: block.templates });
        case 'render-inverse':
          return new RenderInverseIdentitySyntax({ args: block.args, templates: block.templates });
        case 'each':
          return new EachSyntax({ args: block.args, templates: block.templates });
        case 'if':
          return new IfSyntax({ args: block.args, templates: block.templates });
        case 'with':
          return new WithSyntax({ args: block.args, templates: block.templates });
      }
    }

    if (isSimple && (append || block)) {
      let component = this.getComponentDefinition(path, statement);

      if (component) {
        return new CurlyComponentSyntax({ args, definition: component, templates: block && block.templates });
      }
    }

    return super.statement(statement);
  }

  hasHelper(helperName: InternedString[]) {
    return helperName.length === 1 && (<string>helperName[0] in this.helpers);
  }

  lookupHelper(helperParts: string[]) {
    let helperName = helperParts[0];

    let helper = this.helpers[helperName];

    if (!helper) throw new Error(`Helper for ${helperParts.join('.')} not found.`);
    return this.helpers[helperName];
  }

  hasComponentDefinition(name: InternedString[], syntax: StatementSyntax): boolean {
    return !!this.components[<string>name[0]];
  }

  getComponentDefinition(name: InternedString[], syntax: StatementSyntax): ComponentDefinition<any> {
    return this.components[<string>name[0]];
  }

  compile(template: string) {
    return rawCompile(template, { env: this });
  }

  compileLayout(template: string) {
    return rawCompileLayout(template, { env: this });
  }
}

class CurlyComponentSyntax extends StatementSyntax {
  public args: ArgsSyntax;
  public definition: ComponentDefinition<any>;
  public templates: Templates;

  constructor({ args, definition, templates }: { args: ArgsSyntax, definition: ComponentDefinition<any>, templates: Templates }) {
    super();
    this.args = args;
    this.definition = definition;
    this.templates = templates || Templates.empty();
  }

  compile(list: CompileInto, env: Environment) {
    let { definition, templates, args: _args } = this;

    let args = _args.compile(list, env);
    list.append(new OpenComponentOpcode({ definition, args, templates, shadow: null }));
    list.append(new CloseComponentOpcode());
  }
}

interface TemplateWithAttrsOptions {
  defaults?: AttributeSyntax[];
  outers?: AttributeSyntax[];
  identity?: InternedString;
}

interface ComponentParts {
  tag: InternedString;
  attrs: Slice<AttributeSyntax>;
  body: Slice<StatementSyntax>;
}

interface BasicComponentFactory {
  new(attrs: Dict<any>): BasicComponent;
}

abstract class GenericComponentDefinition<T extends Component> extends ComponentDefinition<T> {
  private compiledLayout : CompiledLayout;
  private layout : string;

  constructor(name: string, manager: ComponentManager<any>, ComponentClass: ComponentClass, layout) {
    super(name, manager, ComponentClass);
    this.layout = layout;
  }

  getLayout(env: Environment): CompiledLayout {
    if (!this.compiledLayout) {
      this.compiledLayout = env.compileLayout(this.layout);
    }

    return this.compiledLayout;
  }

  compile({ env }: { env: Environment, symbolTable: SymbolTable}): ComponentParts {
    let { program } = this.getLayout(env);

    let current = program.head();

    while (current && current.type !== 'open-primitive-element') {
      current = current.next;
    }

    return this.extractComponent(<any>current);
  }

  private extractComponent(head: OpenElementSyntax): ComponentParts {
    let tag = head.tag;
    let current = head.next;

    let beginAttrs: AttributeSyntax = null;
    let endAttrs: AttributeSyntax = null;

    while (isAttribute(current)) {
      beginAttrs = beginAttrs || <AttributeSyntax>current;
      endAttrs = <AttributeSyntax>current;
      current = current.next;
    }

    let attrs = new ListSlice(beginAttrs, endAttrs);

    let beginBody: StatementSyntax = null;
    let endBody: StatementSyntax = null;
    let nesting = 1;

    while (true) {
      if (current instanceof CloseElementSyntax && --nesting === 0) {
        break;
      }

      beginBody = beginBody || current;
      endBody = current;

      if (current instanceof OpenElementSyntax || current instanceof OpenPrimitiveElementSyntax) {
        nesting++;
      }

      current = current.next;
    }

    let body = new ListSlice(beginBody, endBody);

    return { tag, attrs, body };
  }
}

class BasicComponentDefinition extends GenericComponentDefinition<BasicComponent> {
  public ComponentClass: BasicComponentFactory;
}

class EmberID extends ExpressionSyntax {
  compile(): CompiledExpression {
    return new CompiledEmberID();
  }
}

class CompiledEmberID extends CompiledExpression {
  type = "ember-id";

  evaluate(vm: VM) {
    return new ValueReference(`ember${vm.getSelf().value()._guid}`);
  }

  toJSON(): string {
    return "`ember${self.guid}`";
  }
}

interface EmberishCurlyComponentFactory {
  create({ attrs }: { attrs: Attrs }): EmberishCurlyComponent;
}

class EmberishCurlyComponentDefinition extends GenericComponentDefinition<EmberishCurlyComponent> {
  public ComponentClass: EmberishCurlyComponentFactory;

  compile({ env } : { env: Environment, symbolTable: SymbolTable }): ComponentParts {
    let tag = 'div' as InternedString;

    let body = this.getLayout(env).program;

    let attrs = new LinkedList<AttributeSyntax>();
    attrs.append(new StaticAttr({ name: 'class' as InternedString, value: 'ember-view' as InternedString }));
    attrs.append(new DynamicAttr({ name: 'id' as InternedString, value: new EmberID() }));

    return { tag, attrs, body };
  }
}

interface EmberishGlimmerComponentFactory {
  create({ attrs }: { attrs: Attrs }): EmberishGlimmerComponent;
}

class EmberishGlimmerComponentDefinition extends GenericComponentDefinition<EmberishGlimmerComponent> {
  public ComponentClass: EmberishGlimmerComponentFactory;

  compile({ env, symbolTable }: { env: Environment, symbolTable: SymbolTable }): ComponentParts {
    let { tag, attrs: _attrs, body } = super.compile({ env, symbolTable });

    let attrs = LinkedList.fromSlice(_attrs);
    attrs.append(new StaticAttr({ name: 'class' as InternedString, value: 'ember-view' as InternedString }));
    attrs.append(new DynamicAttr({ name: 'id' as InternedString, value: new EmberID() }));

    return { tag, attrs, body };
  }
}

export function inspectHooks<T extends Component>(ComponentClass: GlimmerObjectFactory<T>): GlimmerObjectFactory<T> {
  return ComponentClass.extend({
    init() {
      this._super(...arguments);
      this.hooks = {
        didInitAttrs: 0,
        didUpdateAttrs: 0,
        didReceiveAttrs: 0,
        willInsertElement: 0,
        willUpdate: 0,
        willRender: 0,
        didInsertElement: 0,
        didUpdate: 0,
        didRender: 0
      };
    },

    didInitAttrs() {
      this._super(...arguments);
      this.hooks['didInitAttrs']++;
    },

    didUpdateAttrs() {
      this._super(...arguments);
      this.hooks['didUpdateAttrs']++;
    },

    didReceiveAttrs() {
      this._super(...arguments);
      this.hooks['didReceiveAttrs']++;
    },

    willInsertElement() {
      this._super(...arguments);
      this.hooks['willInsertElement']++;
    },

    willUpdate() {
      this._super(...arguments);
      this.hooks['willUpdate']++;
    },

    willRender() {
      this._super(...arguments);
      this.hooks['willRender']++;
    },

    didInsertElement() {
      this._super(...arguments);
      this.hooks['didInsertElement']++;
    },

    didUpdate() {
      this._super(...arguments);
      this.hooks['didUpdate']++;
    },

    didRender() {
      this._super(...arguments);
      this.hooks['didRender']++;
    }
  });
}

type EachOptions = { args: ArgsSyntax };

class EachSyntax extends StatementSyntax {
  type = "each-statement";

  public args: ArgsSyntax;
  public templates: Templates;
  public isStatic = false;

  constructor({ args, templates }: { args: ArgsSyntax, templates: Templates }) {
    super();
    this.args = args;
    this.templates = templates;
  }

  prettyPrint() {
    return `#each ${this.args.prettyPrint()}`;
  }

  compile(compiler: CompileInto, env: Environment) {
    //        PutArgs
    //        EnterList(BEGIN, END)
    // ITER:  Noop
    //        NextIter(BREAK)
    //        EnterWithKey(BEGIN, END)
    // BEGIN: Noop
    //        PushChildScope
    //        Evaluate(default)
    //        PopScope
    // END:   Noop
    //        Exit
    //        Jump(ITER)
    // BREAK: Noop
    //        ExitList

    let BEGIN = new LabelOpcode({ label: "BEGIN" });
    let ITER = new LabelOpcode({ label: "ITER" });
    let BREAK = new LabelOpcode({ label: "BREAK" });
    let END = new LabelOpcode({ label: "END" });

    compiler.append(new PutArgsOpcode({ args: this.args.compile(compiler, env) }));
    compiler.append(new EnterListOpcode(BEGIN, END));
    compiler.append(ITER);
    compiler.append(new NextIterOpcode(BREAK));
    compiler.append(new EnterWithKeyOpcode(BEGIN, END));
    compiler.append(BEGIN);
    compiler.append(new PushChildScopeOpcode());
    compiler.append(new EvaluateOpcode({ debug: "default", block: this.templates.default }));
    compiler.append(new PopScopeOpcode());
    compiler.append(END);
    compiler.append(new ExitOpcode());
    compiler.append(new JumpOpcode({ target: ITER }));
    compiler.append(BREAK);
    compiler.append(new ExitListOpcode());
  }
}

class IdentitySyntax extends StatementSyntax {
  type = "identity";

  public args: ArgsSyntax;
  public templates: Templates;

  constructor({ args, templates }: { args: ArgsSyntax, templates: Templates }) {
    super();
    this.args = args;
    this.templates = templates;
  }

  compile(compiler: CompileInto) {
    compiler.append(new EvaluateOpcode({ debug: "default", block: this.templates.default }));
  }
}

class RenderInverseIdentitySyntax extends StatementSyntax {
  type = "render-inverse-identity";

  public args: ArgsSyntax;
  public templates: Templates;

  constructor({ args, templates }: { args: ArgsSyntax, templates: Templates }) {
    super();
    this.args = args;
    this.templates = templates;
  }

  compile(compiler: CompileInto) {
    compiler.append(new EvaluateOpcode({ debug: "inverse", block: this.templates.inverse }));
  }
}

class IfSyntax extends StatementSyntax {
  type = "if-statement";

  public args: ArgsSyntax;
  public templates: Templates;
  public isStatic = false;

  constructor({ args, templates }: { args: ArgsSyntax, templates: Templates }) {
    super();
    this.args = args;
    this.templates = templates;
  }

  prettyPrint() {
    return `#if ${this.args.prettyPrint()}`;
  }

  compile(compiler: CompileInto, env: Environment) {
    //        Enter(BEGIN, END)
    // BEGIN: Noop
    //        PutArgs
    //        Test
    //        JumpUnless(ELSE)
    //        Evaluate(default)
    //        Jump(END)
    // ELSE:  Noop
    //        Evalulate(inverse)
    // END:   Noop
    //        Exit

    let BEGIN = new LabelOpcode({ label: "BEGIN" });
    let ELSE = new LabelOpcode({ label: "ELSE" });
    let END = new LabelOpcode({ label: "END" });

    compiler.append(new EnterOpcode({ begin: BEGIN, end: END }));
    compiler.append(BEGIN);
    compiler.append(new PutArgsOpcode({ args: this.args.compile(compiler, env) }));
    compiler.append(new TestOpcode());

    if (this.templates.inverse) {
      compiler.append(new JumpUnlessOpcode({ target: ELSE }));
      compiler.append(new EvaluateOpcode({ debug: "default", block: this.templates.default }));
      compiler.append(new JumpOpcode({ target: END }));
      compiler.append(ELSE);
      compiler.append(new EvaluateOpcode({ debug: "inverse", block: this.templates.inverse }));
    } else {
      compiler.append(new JumpUnlessOpcode({ target: END }));
      compiler.append(new EvaluateOpcode({ debug: "default", block: this.templates.default }));
    }

    compiler.append(END);
    compiler.append(new ExitOpcode());
  }
}

class WithSyntax extends StatementSyntax {
  type = "with-statement";

  public args: ArgsSyntax;
  public templates: Templates;
  public isStatic = false;

  constructor({ args, templates }: { args: ArgsSyntax, templates: Templates }) {
    super();
    this.args = args;
    this.templates = templates;
  }

  prettyPrint() {
    return `#with ${this.args.prettyPrint()}`;
  }

  compile(compiler: CompileInto, env: Environment) {
    //        Enter(BEGIN, END)
    // BEGIN: Noop
    //        PutArgs
    //        Test
    //        JumpUnless(ELSE)
    //        Evaluate(default)
    //        Jump(END)
    // ELSE:  Noop
    //        Evaluate(inverse)
    // END:   Noop
    //        Exit

    let BEGIN = new LabelOpcode({ label: "BEGIN" });
    let ELSE = new LabelOpcode({ label: "ELSE" });
    let END = new LabelOpcode({ label: "END" });

    compiler.append(new EnterOpcode({ begin: BEGIN, end: END }));
    compiler.append(BEGIN);
    compiler.append(new PutArgsOpcode({ args: this.args.compile(compiler, env) }));
    compiler.append(new TestOpcode());

    if (this.templates.inverse) {
      compiler.append(new JumpUnlessOpcode({ target: ELSE }));
    } else {
      compiler.append(new JumpUnlessOpcode({ target: END }));
    }

    compiler.append(new EvaluateOpcode({ debug: "default", block: this.templates.default }));
    compiler.append(new JumpOpcode({ target: END }));

    if (this.templates.inverse) {
      compiler.append(ELSE);
      compiler.append(new EvaluateOpcode({ debug: "inverse", block: this.templates.inverse }));
    }

    compiler.append(END);
    compiler.append(new ExitOpcode());
  }
}

export function equalsElement(element: Element, tagName: string, attributes: Object, content: string) {
  QUnit.push(element.tagName === tagName.toUpperCase(), element.tagName.toLowerCase(), tagName, `expect tagName to be ${tagName}`);

  let expectedAttrs: Dict<Matcher> = dict<Matcher>();

  let expectedCount = 0;
  for (let prop in attributes) {
    expectedCount++;
    let expected = attributes[prop];

    let matcher: Matcher = typeof expected === 'object' && MATCHER in expected ? expected : equalsAttr(expected);
    expectedAttrs[prop] = matcher;

    QUnit.push(
      expectedAttrs[prop].match(element.getAttribute(prop)),
      matcher.fail(element.getAttribute(prop)),
      matcher.fail(element.getAttribute(prop)),
      `Expected element's ${prop} attribute ${matcher.expected()}`
    );
  }

  let actualAttributes = {};
  for (let i = 0, l = element.attributes.length; i < l; i++) {
    actualAttributes[element.attributes[i].name] = element.attributes[i].value;
  }

  if (!(element instanceof HTMLElement)) {
    QUnit.push(element instanceof HTMLElement, null, null, "Element must be an HTML Element, not an SVG Element");
  } else {
    QUnit.push(
      element.attributes.length === expectedCount,
      element.attributes.length, expectedCount,
      `Expected ${expectedCount} attributes; got ${element.outerHTML}`
    );

    if (content !== null) {
      QUnit.push(element.innerHTML === content, element.innerHTML, content, `The element had '${content}' as its content`);
    }
  }
}

interface Matcher {
  "3d4ef194-13be-4ccf-8dc7-862eea02c93e": boolean;
  match(actual): boolean;
  fail(actual): string;
  expected(): string;
}

export const MATCHER = "3d4ef194-13be-4ccf-8dc7-862eea02c93e";

export function equalsAttr(expected) {
  return {
    "3d4ef194-13be-4ccf-8dc7-862eea02c93e": true,
    match(actual) {
      return expected === actual;
    },

    expected() {
      return `to equal ${expected}`;
    },

    fail(actual) {
      return `${actual} did not equal ${expected}`;
    }
  };
}

export function equals(expected) {
  return {
    "3d4ef194-13be-4ccf-8dc7-862eea02c93e": true,
    match(actual) {
      return expected === actual;
    },

    expected() {
      return `to equal ${expected}`;
    },

    fail(actual) {
      return `${actual} did not equal ${expected}`;
    }
  };
}

export function regex(r) {
  return {
    "3d4ef194-13be-4ccf-8dc7-862eea02c93e": true,
    match(v) {
      return r.test(v);
    },
    expected() {
      return `to match ${r}`;
    },
    fail(actual) {
      return `${actual} did not match ${r}`;
    }
  };
}

export function classes(expected: string) {
  return {
    "3d4ef194-13be-4ccf-8dc7-862eea02c93e": true,
    match(actual) {
      return actual && (expected.split(' ').sort().join(' ') === actual.split(' ').sort().join(' '));
    },
    expected() {
      return `to include '${expected}'`;
    },
    fail(actual) {
      return `'${actual}'' did not match '${expected}'`;
    }
  };
}
